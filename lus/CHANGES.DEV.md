# Changes between Lus and Lua

## `catch` expression

The `catch` expression is implemented as a compile-time construct that generates two new VM opcodes, with error handling integrated into `luaD_throw`.

#### New Opcodes

**`OP_CATCH` (format: iAsBx)**

- `A`: Destination register for status (results start at A+1)
- `sBx`: Signed offset to jump on error (to instruction after ENDCATCH)

Sets up a protected execution context using `setjmp`. The jump buffer is stored in `CatchInfo` (part of `CallInfo`) to persist across VM instructions.

**`OP_ENDCATCH` (format: iABC)**

- `A`: Destination register (same as OP_CATCH)
- `B`: Expected number of results + 1 (0 = LUA_MULTRET, return all)
- `C`: Jump offset to skip past error handler

Marks successful completion: sets `R[A] = true`, nil-fills if needed, restores the previous error handler, and sets `L->top` appropriately.

#### Modified Structures

**`CatchInfo`** (added to `CallInfo.u.l` in `lstate.h`):

```c
typedef struct CatchInfo {
  jmp_buf jmpbuf;                    /* setjmp buffer for error recovery */
  struct lua_longjmp *prev_errorJmp; /* saved previous error handler */
  volatile TStatus status;           /* error status (if error occurred) */
  const Instruction *errorpc;        /* PC to jump to on error */
  lu_byte destreg;                   /* destination register for status */
  lu_byte nresults;                  /* expected number of results */
  lu_byte active;                    /* 1 if catch block is active */
} CatchInfo;
```

#### Error Handling Flow

1. **Setup (OP_CATCH):**

   - Saves `L->errorJmp` to `catchinfo.prev_errorJmp`
   - Calls `setjmp(catchinfo.jmpbuf)`
   - Sets `catchinfo.active = 1`
   - Normal path: continues to next instruction

2. **Error occurs (luaD_throw modified):**

   - Walks `CallInfo` chain looking for active catch
   - If found: sets `L->ci` to catch frame, `longjmp` to catch's jmpbuf
   - Error path in OP_CATCH: restores `cl`, `k`, `base` (stale after longjmp)
   - Sets `R[A] = false`, `R[A+1] = error message`
   - Reads nresults from ENDCATCH instruction, nil-fills remaining slots
   - Jumps to `errorpc` (past ENDCATCH)

3. **Success (OP_ENDCATCH):**
   - Restores `L->errorJmp` from `prev_errorJmp`
   - Sets `R[A] = true`
   - If B=0 (MULTRET): keeps L->top from inner expression
   - Otherwise: nil-fills up to expected nresults, sets L->top
   - Continues execution

#### Catch Statement

The `catch` keyword can also be used as a statement:

```lua
catch func() -- errors are suppressed, results discarded
```

Implementation adds `catchstat()` in `lparser.c`. It uses the same opcodes but sets `OP_ENDCATCH` B=1 (0 results) and generates code to discard any values generated by the inner expression.

#### Multi-Return Implementation

For inner expressions that are multi-return (VCALL, VVARARG):

- Parser calls `luaK_setmultret()` to let inner expression return all values
- ENDCATCH's B field encodes expected result count (set by `luaK_setreturns`)
- VM nil-fills if actual returns < expected, truncates if more

#### Files Modified

| File         | Changes                                             |
| ------------ | --------------------------------------------------- |
| `llex.h`     | Added `TK_CATCH` token                              |
| `llex.c`     | Added "catch" to reserved words                     |
| `lopcodes.h` | Added `OP_CATCH`, `OP_ENDCATCH`                     |
| `lopcodes.c` | Added opmode entries (ENDCATCH uses iABC)           |
| `lopnames.h` | Added opcode names for disassembler                 |
| `ljumptab.h` | Added jump table entries                            |
| `lstate.h`   | Added `CatchInfo` struct, `#include <setjmp.h>`     |
| `lparser.h`  | Added `VCATCH` expression kind                      |
| `lparser.c`  | Added `catchexpr()`, updated `hasmultret()`         |
| `lcode.c`    | Updated `luaK_setreturns()`, `luaK_dischargevars()` |
| `ldo.c`      | Modified `luaD_throw()` to check for active catch   |
| `lvm.c`      | Implemented `OP_CATCH` and `OP_ENDCATCH` handlers   |
| `luac.c`     | Added disassembly support for new opcodes           |
| `lbaselib.c` | Removed `pcall` and `xpcall` functions              |

#### Key Implementation Details

- The `jmp_buf` must be stored in `CatchInfo` (not as a local variable) because it needs to persist across VM instruction boundaries.
- After `longjmp`, local variables in `luaV_execute` are stale. The error path must refresh `ci`, `cl`, `k`, and `base` from `L->ci`.
- Register allocation follows VCALL conventions: `freereg = base + 1` after parsing, letting `adjust_assign` handle multi-value cases.
- For multi-return inner expressions, `luaK_setmultret()` is called to preserve all return values.
- ENDCATCH reads nresults from its B field and nil-fills/truncates accordingly.
- On error, nresults is read from the ENDCATCH instruction (at errorpc - 1) for proper nil-filling.

## Assignments in `if`/`elseif` conditions

The `if`/`elseif` assignment condition feature is implemented entirely in the parser (`lparser.c`), requiring no new opcodes or VM changes. It leverages existing local variable and test instruction machinery.

#### Parser Changes

**New function `isassigncond()`:**

Detects assignment conditions by checking if the current token is `TK_NAME` and the lookahead is `=` (single equals) or `,`. This distinguishes `if a = 1 then` from `if a == 1 then`.

**New function `assigncond()`:**

Parses the assignment condition syntax: `NAME { ',' NAME } '=' explist`

1. Parses variable names using `str_checkname()`, declaring each with `new_localvar()`
2. Consumes `=` and parses expression list with `explist()`
3. Uses `adjust_assign()` to handle value count mismatches (nil-filling)
4. Activates variables with `adjustlocalvars()` (values now in registers)
5. For each variable, creates a `VNONRELOC` expression and calls `luaK_goiftrue()` to generate a `TEST` instruction
6. Chains all false-jump lists together (if ANY variable is false/nil, jump to next condition)

**Modified `test_then_block()`:**

Now checks `isassigncond()` after skipping `IF`/`ELSEIF`. If true, calls `assigncond()` instead of `cond()` for condition parsing.

**Modified `ifstat()`:**

Wraps the entire `if`/`elseif`/`else`/`end` construct in an outer `BlockCnt` scope using `enterblock()`/`leaveblock()`. This ensures:

- Variables declared in any condition remain visible through all subsequent blocks
- Variables from a failed `if` condition are accessible in `elseif` and `else` blocks
- All condition variables go out of scope when `end` is reached

#### Code Generation

For `if a, b = x, y then`:

```
EVAL x -> R[base]          ; evaluate first expression
EVAL y -> R[base+1]        ; evaluate second expression
; (variables a, b now active)
TEST R[base]               ; if a is false, jump to false_branch
JMP false_branch
TEST R[base+1]             ; if b is false, jump to false_branch
JMP false_branch
... then block ...
JMP end                    ; escape to end (if elseif/else follows)
false_branch:              ; next condition or else block
```

Each variable's truthiness is tested with `OP_TEST`. The false-jump lists are concatenated, so if ANY value is false/nil, execution jumps to the next condition.

#### Scoping Implementation

The outer block in `ifstat()` creates a scope that encompasses:

- All `if`/`elseif` condition assignments
- All `then` blocks
- The `else` block (if any)

This differs from standard Lua where each block has its own scope. The nested `block()` calls create inner scopes, but condition variables live in the outer scope and remain accessible across all branches.

#### Files Modified

| File        | Changes                                                                             |
| ----------- | ----------------------------------------------------------------------------------- |
| `lparser.c` | Added `isassigncond()`, `assigncond()`, modified `test_then_block()` and `ifstat()` |

#### Key Implementation Details

- No new tokens, opcodes, or VM changes are required
- Detection relies on lookahead: `NAME` followed by `=` or `,` indicates assignment
- Multiple variables generate multiple `TEST` instructions with chained false-jumps
- The outer `BlockCnt` ensures proper variable lifetime across the entire if statement
- Variables from earlier conditions are visible in later conditions due to shared outer scope
- Standard `adjust_assign()` handles expression count mismatches (extra variables become nil, which causes the condition to fail)

## `?` conditional (optional chaining) expression

The `?` operator enables safe navigation through potentially nil values. If the value before `?` is falsy (nil or false), subsequent suffix operations (field access, indexing, method calls, function calls) short-circuit and return the falsy value instead of raising an error.

#### Parser Changes

The implementation modifies `suffixedexp()` in `lparser.c` to handle the `?` token as a special suffix operation.

**New function `discharge2basereg()`:**

Helper function that discharges an expression to a specific register (the "base register" for the optional chain). This ensures all operations in a chain write to the same register, so when we short-circuit, the register already contains the falsy value.

**Modified `suffixedexp()`:**

Tracks two new pieces of state:

- `niljumps`: A jump list for all short-circuit exits
- `basereg`: The register holding the chain result (-1 if not in a chain)

When `?` is encountered:

1. On first `?`: Put value in a fresh register (not a local!) and record as `basereg`
2. On subsequent `?`: Discharge current expression to `basereg`
3. Emit `TEST basereg 0` followed by `JMP` to test for falsy value
4. Add the jump to `niljumps`

After each suffix operation (`.`, `[]`, `:`, `()`), if in an optional chain, discharge the result to `basereg` to maintain the single-register invariant.

At the end of `suffixedexp()`, patch all `niljumps` to the current position.

#### Code Generation

For `t?.a?.b`:

```
GETTABUP R0 _ENV "t"      ; get t
MOVE     R1 R0            ; copy to chain register R1
TEST     R1 0             ; if R1 is truthy, skip next
JMP      L1               ; jump to end if falsy
GETFIELD R1 R1 "a"        ; R1 = t.a
TEST     R1 0             ; if R1 is truthy, skip next
JMP      L1               ; jump to end if falsy
GETFIELD R1 R1 "b"        ; R1 = t.a.b
L1:                       ; result in R1
```

Key insight: All operations write to the same register (`R1`). When we jump due to a falsy value, the register already contains that value, so no explicit nil-load is needed.

#### Register Management

Critical implementation detail: The base register must be a fresh register, not a local variable's register. If we used the local's register directly, we would corrupt the local's value during the chain operations.

The `discharge2basereg()` function ensures:

1. For `VRELOC` expressions: Sets the instruction's destination to `basereg`
2. For `VNONRELOC` in different register: Emits `MOVE` to `basereg`
3. Updates `freereg` to `basereg + 1` to prevent register allocation conflicts

#### Files Modified

| File        | Changes                                                                                    |
| ----------- | ------------------------------------------------------------------------------------------ |
| `lparser.c` | Added `discharge2basereg()`, modified `suffixedexp()` to handle `?` token and track chains |

#### Key Implementation Details

- No new tokens or opcodes required; `?` is handled as ASCII value 63
- Uses existing `TEST` opcode for falsy check (nil OR false)
- When falsy, short-circuits by jumping over remaining suffix operations
- The result is the original falsy value (not explicitly nil) because the register isn't modified after the jump
- Parenthesized expressions like `(expr)?.field` work naturally because each `suffixedexp()` call has its own chain state
- Deep chains like `t?.a?.b?.c?.d?.e` are efficient: each `?` adds only `TEST` + `JMP` (2 instructions)

## `from` table deconstruction expression

The `from` keyword enables extracting multiple fields from a table using the variable names as field keys. It works with local declarations, global declarations, and regular assignments.

**Syntax:**

```lua
local a, b, c from t    -- equivalent to: local a, b, c = t.a, t.b, t.c
global a, b, c from t   -- equivalent to: global a, b, c = t.a, t.b, t.c
a, b, c from t          -- equivalent to: a, b, c = t.a, t.b, t.c
```

#### Lexer Changes

Added `TK_FROM` to the reserved words enum in `llex.h` and the corresponding "from" string in `llex.c`.

#### Parser Changes

**New function `localfrom()`:**

Handles `local NAME { ',' NAME } from expr`:

1. Reserves registers for all local variables first (`luaK_reserveregs`)
2. Parses the source table expression into the next available register
3. For each variable, generates a `GETFIELD` instruction with the variable name as key, writing directly to the reserved register slot
4. Sets `freereg` to after the local variables (dropping the temp table register)
5. Activates the local variables with `adjustlocalvars()`

**New function `globalfrom()`:**

Handles `global NAME { ',' NAME } from expr`:

Uses a recursive structure (like `initglobal`):

1. Recursively builds global variable descriptions with `buildglobal()`
2. At the base case (n == nvars): reserves registers, parses table, generates `GETFIELD` for each field
3. On the way back: calls `checkglobal()` (Lua 5.5 global checking) and `storevartop()` to store each value

**New function `assignfrom()`:**

Handles bare `NAME { ',' NAME } from expr` assignment:

1. Collects variable names from the LHS chain (stored in reverse order)
2. Reserves registers for field values
3. Parses the source table expression
4. Generates `GETFIELD` for each field into reserved registers
5. Stores each value to its variable using `storevartop()`

**Modified `restassign()`:**

- Changed return type to `int` to signal whether `from` was used
- Added `TK_FROM` case that calls `assignfrom()` and returns 1
- Outer recursive calls check return value and skip `storevartop` if inner call used `from`

**Modified `exprstat()`:**

Added `TK_FROM` to the condition that triggers assignment parsing.

**Modified `globalnames()`:**

Added `TK_FROM` case that calls `globalfrom()` instead of `initglobal()`.

**Modified `localstat()`:**

Added `TK_FROM` case that calls `localfrom()` instead of the normal initialization path.

#### Code Generation

For `local a, b, c from t`:

```
; t is in R[0]
MOVE     R[4] R[0]       ; copy table to temp register
GETFIELD R[1] R[4] "a"   ; R[1] = t.a
GETFIELD R[2] R[4] "b"   ; R[2] = t.b
GETFIELD R[3] R[4] "c"   ; R[3] = t.c
; locals a, b, c are now in R[1], R[2], R[3]
```

For `global a, b, c from t`:

```
; t is in R[0]
MOVE     R[4] R[0]       ; copy table to temp register
GETFIELD R[1] R[4] "a"   ; R[1] = t.a
GETFIELD R[2] R[4] "b"   ; R[2] = t.b
GETFIELD R[3] R[4] "c"   ; R[3] = t.c
GETTABUP R[4] _ENV "c"   ; check _ENV.c exists (Lua 5.5)
ERRNNIL  R[4] "c"
SETTABUP _ENV "c" R[3]   ; _ENV.c = R[3]
GETTABUP R[3] _ENV "b"   ; check _ENV.b exists
ERRNNIL  R[3] "b"
SETTABUP _ENV "b" R[2]   ; _ENV.b = R[2]
GETTABUP R[2] _ENV "a"   ; check _ENV.a exists
ERRNNIL  R[2] "a"
SETTABUP _ENV "a" R[1]   ; _ENV.a = R[1]
```

#### Register Management

Critical insight: After reserving registers for field values, the table expression must go into a register AFTER those reserved slots. This prevents the `freereg(fs, tblreg)` calls in `luaK_dischargevars` from corrupting the field value registers.

The pattern used:

1. `base = fs->freereg` - remember where field values will go
2. `luaK_reserveregs(fs, nvars)` - reserve slots for field values
3. Parse table, put in next register (`luaK_exp2nextreg`)
4. Generate `GETFIELD` with explicit destination registers (`base + i`)
5. Set `freereg = base + nvars` - drop temp table register

#### Files Modified

| File        | Changes                                                                                                                    |
| ----------- | -------------------------------------------------------------------------------------------------------------------------- |
| `llex.h`    | Added `TK_FROM` to reserved words enum                                                                                     |
| `llex.c`    | Added "from" to token strings array                                                                                        |
| `lparser.c` | Added `localfrom()`, `globalfrom()`, `assignfrom()`, modified `localstat()`, `globalnames()`, `restassign()`, `exprstat()` |

#### Key Implementation Details

- `from` is a new reserved word (required because it appears in statement context)
- Variable names become field keys: `local x, y from t` accesses `t.x` and `t.y`
- Fields that don't exist evaluate to `nil` (standard Lua table semantics)
- The table expression is evaluated only once (not once per field)
- Works with Lua 5.5's global declaration system (`global` keyword and checking)
- No new opcodes required; uses existing `GETFIELD` instruction

## Enums

Enums are a new type that provide symbolic constants with identity-based comparison. Each enum value belongs to an "enum root" which defines the set of valid names and their indices.

#### Type System

**New type constant in `lua.h`:**

- `LUA_TENUM = 9` - The enum base type
- `LUA_NUMTYPES` updated to 10

**Variant tags in `lobject.h`:**

- `LUA_VENUM` - User-visible enum value
- `LUA_VENUMROOT` - Internal enum root (holds name-to-index mapping)

#### Data Structures

**`EnumRoot`** (internal, not directly accessible to users):

```c
typedef struct EnumRoot {
  CommonHeader;
  int size;           /* number of enum values */
  GCObject *gclist;   /* for GC traversal */
  TString *names[1];  /* flexible array: names[0..size-1] */
} EnumRoot;
```

**`Enum`** (user-visible enum value):

```c
typedef struct Enum {
  CommonHeader;
  struct EnumRoot *root;  /* the enum definition */
  int idx;                /* 1-based index */
} Enum;
```

#### Lexer Changes

Added `TK_ENUM` to the reserved words enum in `llex.h` and the corresponding "enum" string in `llex.c`.

#### Parser Changes

**New function `enumexpr()`:**

Parses `enum NAME { ',' NAME } end`:

1. Skips `TK_ENUM`
2. Collects all names into an array using `str_checkname()`
3. Creates the EnumRoot with `luaE_newroot()`
4. Creates the first enum value with `luaE_new()`
5. Adds the enum value as a constant with `luaK_enumK()`
6. Returns expression pointing to the constant

**Modified `simpleexp()`:**

Added `TK_ENUM` case that calls `enumexpr()`.

#### Code Generation

For `local a = enum x, y, z end`:

```
LOADK    R[0] K[0]     ; K[0] is the first enum value (index 1)
; (local 'a' is now in R[0])
```

The enum root and first value are created at compile time and stored as constants.

#### VM Changes

**Enum Indexing:**

When indexing an enum value:

1. **By string**: Look up the name in the root's `names` array. If found, create/return an enum value with that index. If not found, error.

2. **By integer**: Check bounds (1 to size). If valid, create/return an enum value with that index. If invalid, error.

**Modified `luaV_finishget()`:**

Added handling for `LUA_TENUM` type to perform enum-specific indexing.

#### Garbage Collection

**Traversal (`lgc.c`):**

- `traverseenum()`: Marks the enum's root
- `traverseenumroot()`: Marks all name strings in the root

**Freeing:**

- `freeobj()` updated to handle `LUA_VENUM` and `LUA_VENUMROOT`
- EnumRoot frees its names array
- Enum values are simple fixed-size allocations

#### C API

**New functions in `lapi.c`:**

```c
/* Push an enum onto the stack from pairs on the stack.
** Usage: push string/number pairs, then call lua_pushenum(L, npairs).
** Example:
**   lua_pushstring(L, "foo");
**   lua_pushinteger(L, 1);
**   lua_pushstring(L, "bar");
**   lua_pushinteger(L, 2);
**   lua_pushenum(L, 2);  // creates enum{foo=1, bar=2}, pushes foo
*/
LUA_API void lua_pushenum (lua_State *L, int npairs);

/* Check if value at index is an enum */
LUA_API int lua_isenum (lua_State *L, int idx);

/* Get the integer index of an enum value (1-based) */
LUA_API lua_Integer lua_toenumidx (lua_State *L, int idx);
```

**Updated functions:**

- `lua_type()`: Returns `LUA_TENUM` for enum values
- `lua_typename()`: Returns "enum" for `LUA_TENUM`

#### Base Library Changes

**`tonumber()`:**

Updated to handle enums: returns the 1-based index of the enum value.

**`type()`:**

Returns "enum" for enum values (automatic via `lua_typename`).

#### Comparison Semantics

- **Equality (`==`, `~=`)**: Two enum values are equal only if they have the same root AND the same index.
- **Ordering (`<`, `<=`, `>`, `>=`)**: Enums compare by their numeric indices (allows `enum_a.x < enum_a.y`).
- **Cross-enum comparison**: Different enum roots are never equal, but ordering comparison between them raises an error (or compares by index, TBD).

#### Files Modified/Created

| File          | Changes                                                             |
| ------------- | ------------------------------------------------------------------- |
| `lua.h`       | Added `LUA_TENUM`, updated `LUA_NUMTYPES`                           |
| `lobject.h`   | Added `LUA_VENUM`, `LUA_VENUMROOT`, Enum/EnumRoot structs, macros   |
| `lstate.h`    | Added Enum/EnumRoot to GCUnion, gco2enum/gco2enumroot macros        |
| `lenum.h`     | **NEW**: Enum function declarations                                 |
| `lenum.c`     | **NEW**: Enum implementation                                        |
| `llex.h`      | Added `TK_ENUM` to reserved words enum                              |
| `llex.c`      | Added "enum" to token strings                                       |
| `ltm.c`       | Added "enum" to type names array                                    |
| `lgc.c`       | Added traverseenum, traverseenumroot, updated freeobj/propagatemark |
| `lparser.c`   | Added `enumexpr()`, updated `simpleexp()`                           |
| `lcode.c`     | Added `luaK_enumK()` for enum constants                             |
| `lvm.c`       | Updated `luaV_finishget()` for enum indexing                        |
| `lapi.c`      | Added `lua_pushenum()`, `lua_isenum()`, `lua_toenumidx()`           |
| `lbaselib.c`  | Updated `tonumber` to handle enums                                  |
| `meson.build` | Added `lenum.c` to sources                                          |

#### Key Implementation Details

- Enum roots are created at parse time and stored as constants in the function prototype
- All enum values in a family share the same root pointer (identity comparison)
- The root's `names` array is allocated inline using flexible array member
- Enum indexing by string is O(n) for simplicity; could be optimized with hash lookup
- No new opcodes required; enum indexing uses existing `GETTABLE`/`GETFIELD` paths with type-specific handling in `luaV_finishget()`
- Cross-enum ordering comparisons error (different "types" of enums shouldn't be compared for order)

## JSON

Lus adds RFC 8259 compliant `tojson` and `fromjson` global functions for JSON serialization and deserialization. [Tested against 369 RFC 8259 test files (95 valid, 188 invalid, 86 implementation-defined)](https://github.com/nst/JSONTestSuite).

#### API

**`fromjson(json_string)`**

- Parses JSON string into Lua value
- Returns: `table`, `string`, `number`, `boolean`, or `nil`
- Throws error on invalid JSON with position information

**`tojson(value, [filter])`**

- Serializes Lua value to compact JSON string
- Optional `filter(key, value)` callback for transformation/filtering
- Returns `nil` from filter to omit a property
- `__json` metamethod: if present, called with `self`, return value is serialized instead

#### Implementation

The implementation is in `ljsonlib.c` with an iterative state-machine parser and recursive serializer.

**Parser Features:**

- All JSON types: strings, numbers, booleans, null, arrays, objects
- Escape sequences: `\"`, `\\`, `\/`, `\b`, `\f`, `\n`, `\r`, `\t`, `\uXXXX`
- Surrogate pair handling for supplementary Unicode characters
- Clear error messages with byte position
- Iterative design using direct object manipulation (no Lua stack overflow)

**Serializer Features:**

- Automatic array vs object detection (contiguous 1..n integer keys = array)
- `inf`/`-inf`/`nan` serialized as `null` (per RFC 8259)
- Cycle detection with error on circular references
- Skips unsupported types: functions, threads, enums, userdata (without `__json`)

#### Files Created/Modified

| File          | Changes                                           |
| ------------- | ------------------------------------------------- |
| `ljsonlib.c`  | **NEW**: JSON parser and serializer (~1030 lines) |
| `lualib.h`    | Added `luaopen_json` declaration                  |
| `linit.c`     | Call `luaopen_json()` to register globals         |
| `meson.build` | Added `ljsonlib.c` to lib_sources                 |

## Filesystem Library (`fs`)

Lus introduces a dedicated `fs` library for filesystem operations, fixing cross-platform inconsistencies in the standard `os` library and adding missing features like directory listing, recursive removal, and symlink handling.

#### Design

The `fs` library is implemented in C (`lfslib.c`) and exposed as a global `fs` table. It prioritizes cross-platform consistency (Windows vs POSIX) while providing access to platform-specific needs where unavoidable (e.g., path separators).

**Removed Functions:**

- `os.remove`
- `os.rename`

(These are superseded by `fs.remove` and `fs.move`).

#### API

**File Operations:**

- `fs.list(dir, [glob])`: Returns an array of filenames in `dir`. Supports basic glob patterns (`*`, `?`).
- `fs.copy(src, dst)`: Copies file `src` to `dst`.
- `fs.move(src, dst)`: Moves/renames `src` to `dst`.
- `fs.remove(path, [recursive])`: Removes file or directory. Recursive if second arg is true.
- `fs.type(path)`: Returns "file", "directory", or raises error. Returns second value boolean `is_link`.
- `fs.createdirectory(path, [recursive])`: Creates a new directory. If `recursive` is true, creates parent directories as needed.

**Symlinks:**

- `fs.createlink(linkname, target)`: Creates a symbolic link.
- `fs.follow(path)`: Resolves a symlink to its target path. (On Windows, implemented via `GetFinalPathNameByHandle`).

**Path Manipulation (`fs.path`):**

- `fs.path.join(...)`: Joins path components with platform separator.
- `fs.path.split(path)`: Splits path into components.
- `fs.path.name(path)`: Returns the filename part.
- `fs.path.parent(path)`: Returns the parent directory part.
- `fs.path.separator`: `/` or `\`
- `fs.path.delimiter`: `:` or `;`

#### Implementation Details

- **Cross-Platform**: Uses `#if defined(LUS_PLATFORM_WINDOWS)` to select between Win32 API (`FindFirstFile`, `CopyFile`, `GetFinalPathNameByHandle`) and POSIX (`opendir`, `sendfile` fallback, `readlink`)
- **Recursive Remove**: Implemented manually to handle directory traversal and file deletion safely on both platforms.
- **Symlinks on Windows**: `fs.follow` extracts the final path and strips the `\\?\` prefix if present.

#### Files Modified

| File          | Changes                              |
| ------------- | ------------------------------------ |
| `lfslib.c`    | **NEW**: `fs` library implementation |
| `loslib.c`    | Removed `os.remove` and `os.rename`  |
| `linit.c`     | Registered `fs` library              |
| `lualib.h`    | Added `luaopen_fs`                   |
| `meson.build` | Added `lfslib.c` to build sources    |

## `string.transcode`

Lus adds a universal encoding transcoding function to the string library, enabling conversion between various text encodings and binary-to-text formats.

#### API

**`string.transcode(data, from, to [, ignorebad])`**

Transcodes the input string from the source encoding to the destination encoding.

**Parameters:**

- `data`: The input string (raw byte buffer)
- `from`: Source encoding name (string)
- `to`: Target encoding name (string)
- `ignorebad`: Optional boolean. If true, silently skips invalid/untranscodable characters instead of raising an error

**Returns:** The transcoded string

**Throws:** Error if encoding is invalid or data cannot be transcoded (unless `ignorebad` is true)

#### Supported Encodings

| Encoding     | Description                                                           |
| ------------ | --------------------------------------------------------------------- |
| `ascii`      | 7-bit ASCII (bytes 0-127)                                             |
| `utf-8`      | Standard UTF-8                                                        |
| `utf-8bom`   | UTF-8 with Byte Order Mark (strips BOM on decode, adds BOM on encode) |
| `utf-16le`   | Little-endian UTF-16 (with surrogate pair support)                    |
| `iso-8859-1` | Latin-1 single-byte encoding (alias: `latin-1`)                       |
| `base64`     | Base64 binary-to-text encoding                                        |
| `url`        | URL encoding                                                          |
| `hex`        | Hexadecimal representation                                            |

#### Encoding Categories

**Character-based encodings** (`ascii`, `utf-8`, `utf-8bom`, `utf-16le`, `iso-8859-1`):

- Transcode via Unicode codepoints
- Characters that cannot be represented in the target encoding trigger an error (or are skipped with `ignorebad`)

**Binary-to-text encodings** (`base64`, `url`, `hex`):

- When used as `from`: Decode the formatted string to raw bytes
- When used as `to`: Encode raw bytes to the formatted string
- Can be chained (e.g., `base64` → `hex` decodes base64 to bytes, then encodes as hex)

#### Implementation Details

**UTF-16LE Endianness:**

The implementation explicitly handles byte order rather than relying on host architecture:

```c
/* Reading UTF-16LE (always little-endian) */
static l_uint32 read_utf16le(const unsigned char *p) {
  return (l_uint32)p[0] | ((l_uint32)p[1] << 8);
}

/* Writing UTF-16LE (always little-endian) */
static void write_utf16le(unsigned char *p, l_uint32 val) {
  p[0] = (unsigned char)(val & 0xFF);
  p[1] = (unsigned char)((val >> 8) & 0xFF);
}
```

**Surrogate Pair Handling:**

UTF-16LE correctly handles supplementary plane characters (U+10000 to U+10FFFF) via surrogate pairs:

- Encoding: Codepoints > U+FFFF are split into high (0xD800-0xDBFF) and low (0xDC00-0xDFFF) surrogates
- Decoding: Surrogate pairs are combined back into the original codepoint
- Lone surrogates trigger an error

**UTF-8 BOM:**

- Decoding `utf-8bom`: Strips the 3-byte BOM (EF BB BF) if present at the start
- Encoding to `utf-8bom`: Prepends the BOM to the output

**URL Encoding:**

- Encodes all bytes except unreserved characters (A-Z, a-z, 0-9, `-`, `_`, `.`, `~`)
- Decodes `%XX` hex sequences and `+` (as space)

**Base64:**

- RFC 4648 standard alphabet (`A-Za-z0-9+/` with `=` padding)
- Ignores whitespace during decoding

#### Example Usage

```lua
-- Base64 decoding
local raw = string.transcode("dXNlcjpwYXNzd29yZA==", "base64", "utf-8")
print(raw) -- "user:password"

-- URL encoding
local safe = string.transcode("hello world & others", "utf-8", "url")
print(safe) -- "hello%20world%20%26%20others"

-- Hex dump
local hex = string.transcode("Lus", "utf-8", "hex")
print(hex) -- "4c7573"

-- UTF-8 to UTF-16LE
local utf16 = string.transcode("Hello", "utf-8", "utf-16le")
-- utf16 == "H\0e\0l\0l\0o\0"

-- Character set conversion with fallback
local latin = string.transcode("日本語", "utf-8", "iso-8859-1", true)
print(latin) -- "" (characters skipped, cannot be represented)
```

#### Files Modified

| File        | Changes                                             |
| ----------- | --------------------------------------------------- |
| `lstrlib.c` | Added `str_transcode` and encoding helper functions |

## `network` Library

The `network` library provides native TCP, UDP, and HTTP/HTTPS networking capabilities through a new source file `lnetlib.c`.

#### External Dependencies

- **OpenSSL**: Required for HTTPS/TLS support
- **c-ares**: Async DNS resolution library

#### Platform Abstraction

Cross-platform socket abstraction using preprocessor directives:

```c
#if defined(LUS_PLATFORM_WINDOWS)
  typedef SOCKET socket_t;
  #define sock_close closesocket
  // Winsock initialization via WSAStartup
#else
  typedef int socket_t;
  #define sock_close close
  // POSIX sockets (Linux, macOS, BSD)
#endif
```

#### Userdata Types

Three userdata types with metatables:

| Type | Metatable | Description |
|------|-----------|-------------|
| `LSocket` | `network.socket` | TCP client connection |
| `LServer` | `network.server` | TCP listening server |
| `LUDPSocket` | `network.udpsocket` | UDP datagram socket |

Each includes `__gc`, `__close`, and `__tostring` metamethods.

#### API Functions

**TCP:**
- `network.tcp.connect(address, port)` → Socket
- `network.tcp.bind(address, port, [backlog])` → Server
- `socket:send(data)`, `socket:receive([pattern])`, `socket:close()`, `socket:settimeout(sec)`
- `server:accept()`, `server:close()`, `server:settimeout(sec)`

**UDP:**
- `network.udp.open([port], [address])` → UDPSocket
- `udp:sendto(data, addr, port)`, `udp:receive([size])`, `udp:close()`

**HTTP:**
- `network.fetch(url, [method], [headers], [body])` → status, body, headers

#### DNS Resolution

Uses c-ares `ares_getaddrinfo()` for async-capable DNS lookups supporting IPv4/IPv6.

#### TLS/HTTPS

OpenSSL integration for secure connections:
- `SSL_CTX` created once at library init
- `SSL_connect()` for handshake, `SSL_read()`/`SSL_write()` for I/O
- Certificate verification via system CA certificates

#### Files Modified

| File | Changes |
|------|---------|
| `lnetlib.c` | NEW - Full network library implementation (~1600 lines) |
| `linit.c` | Register `luaopen_network` in stdlibs |
| `lualib.h` | Add `LUA_NETLIBNAME`, `LUA_NETLIBK`, `luaopen_network` |
| `meson.build` | Add `lnetlib.c`, OpenSSL/c-ares deps, Winsock for Windows |

#### Async I/O for Event Loop

Network operations in detached coroutines automatically use non-blocking I/O:

**Async Functions:**

- `socket:send()` - Yields on `EWOULDBLOCK`, preserves bytes-sent progress via `lua_KContext`
- `socket:receive()` - All patterns (`*l`, `*a`, bytes) yield on `EWOULDBLOCK`
- Event loop waits for fd readiness, then resumes coroutine

**Implementation Pattern:**

```c
static int recv_bytes(lua_State *L, LSocket *sock, size_t n) {
  int detached = is_detached(L);
  
  if (detached) {
    set_nonblocking(sock->fd, 1);
  }
  
  // ... receive loop ...
  
  if (got == SOCKET_ERROR_VAL) {
    int err = SOCKET_ERRNO;
    if (err == SOCKET_EWOULDBLOCK) {
      if (detached) {
        set_yield_reason(L, YIELD_IO);
        set_yield_fd(L, (int)sock->fd);
        set_yield_events(L, EVLOOP_READ);
        return lua_yield(L, 0);
      }
    }
  }
  
  if (detached) set_nonblocking(sock->fd, 0);
  return 1;
}
```

## Event Loop

Lus provides an opt-in event loop for running detached coroutines with non-blocking I/O and timed sleeps. The event loop uses platform-native backends and integrates seamlessly with the coroutine API.

#### Design Philosophy

- **Opt-in**: Only coroutines explicitly marked with `coroutine.detach()` participate in event-driven execution
- **Explicit polling**: User controls event processing via `coroutine.poll()`
- **Native backends**: Uses OS-native event APIs (epoll, kqueue, IOCP) for efficiency
- **Thread pool**: Background thread pool for file I/O and blocking operations

#### Coroutine API Extensions

**`coroutine.detach(co)` → status_e**

Starts a coroutine for event-driven execution. Runs immediately until async I/O or completion:

```lua
local co = coroutine.create(function()
  coroutine.sleep(0.1)
  return "done"
end)

local status = coroutine.detach(co)
if status == coroutine.status_e.pending then
  -- Coroutine is waiting on async I/O
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
end
```

Returns a `coroutine.status_e` enum value:
- `pending`: Coroutine yielded on async I/O, waiting in event loop
- `completed`: Coroutine finished synchronously
- `yielded`: Coroutine called regular `coroutine.yield()`
- `error`: Coroutine threw an error

**`coroutine.poll([timeout_secs])` → void**

Processes the event loop, resuming ready coroutines. Throws any errors from completed coroutines:

```lua
while coroutine.pending() > 0 do
  catch coroutine.poll(5)  -- 5 second timeout
end
```

**`coroutine.pending()` → integer**

Returns the count of coroutines waiting in the event loop.

**`coroutine.sleep(seconds)`**

Yields execution for a specified duration (only valid in detached coroutines):

```lua
coroutine.sleep(0.5)    -- sleep 500ms
coroutine.sleep(0.001)  -- sleep 1ms
coroutine.sleep(0)      -- yield immediately
```

#### Implementation

**Header File (`lev.h`):**

```c
/* Yield reasons for detached coroutines */
#define YIELD_NORMAL 0     /* Regular yield */
#define YIELD_IO 1         /* Waiting for I/O */
#define YIELD_SLEEP 2      /* Sleeping for duration */
#define YIELD_THREADPOOL 3 /* Waiting for thread pool task */

/* Event flags */
#define EVLOOP_READ 1
#define EVLOOP_WRITE 2
#define EVLOOP_ERROR 4

/* Scheduler management */
Scheduler *scheduler_get(lua_State *L);
void scheduler_init(lua_State *L);
void scheduler_cleanup(lua_State *L);

/* Pending coroutine management */
void scheduler_add_pending(lua_State *L, lua_State *co, int fd,
                           int events, lua_Number deadline);
int scheduler_poll(lua_State *L, int timeout_ms);
int scheduler_pending_count(lua_State *L);

/* Thread pool access */
ThreadPool *scheduler_get_threadpool(lua_State *L);
```

**Scheduler Structure (`lev.c`):**

```c
struct Scheduler {
  EventBackend *backend;     /* Platform-specific event backend */
  const BackendOps *ops;     /* Backend operations */
  ThreadPool *threadpool;    /* Thread pool for async work */
  PendingCoroutine *pending; /* Linked list of pending coroutines */
  int pending_count;
  char *pending_error;       /* Error to throw on next poll() */
};
```

#### Platform Backends

**epoll (Linux):**
- Efficient edge-triggered event notification
- Uses `epoll_create1()`, `epoll_ctl()`, `epoll_wait()`

**kqueue (macOS/BSD):**
- Kernel event queue with efficient batching
- Uses `kqueue()`, `kevent()`

**IOCP (Windows):**
- I/O Completion Ports for async I/O
- Uses `CreateIoCompletionPort()`, `GetQueuedCompletionStatusEx()`

**select (fallback):**
- Portable fallback for platforms without native async

#### Thread Pool

The scheduler includes a thread pool for blocking operations that cannot use event-driven I/O (file operations, etc.):

**Header (`lev_threadpool.h`):**

```c
typedef struct ThreadPoolTask ThreadPoolTask;
typedef void (*ThreadPoolWorkFn)(ThreadPoolTask *task);

struct ThreadPoolTask {
  ThreadPoolWorkFn work;    /* Function to execute in worker */
  void *userdata;           /* Task-specific data */
  void *result;             /* Result from worker */
  char *error;              /* Error message if failed */
  volatile int done;        /* Completion flag */
};

ThreadPool *threadpool_create(int num_threads);
void threadpool_destroy(ThreadPool *pool);
void threadpool_submit(ThreadPool *pool, ThreadPoolTask *task);
int threadpool_poll(ThreadPool *pool, ThreadPoolTask **completed, int max);
```

**Implementation (`lev_threadpool.c`):**

Cross-platform implementation using:
- **POSIX**: pthreads + pipe for notification
- **Windows**: Win32 threads + event for notification

Worker threads perform blocking I/O in the background. The scheduler polls for completion and resumes waiting coroutines.

#### Making C Code Async-Aware

Documentation in `lev.c` explains how to make Lus C functions async-aware:

1. **Check detached state**: `if (is_detached(L)) { ... }`
2. **For socket I/O**: Yield with `YIELD_IO`, `set_yield_fd()`, `set_yield_events()`
3. **For blocking work**: Use thread pool, yield with `YIELD_THREADPOOL`
4. **For sleeps**: Yield with `YIELD_SLEEP`, `set_yield_deadline()`

**Key constraint**: Worker threads must NEVER touch `lua_State` (GIL).

#### Async File I/O

File operations in `liolib.c` are async-aware in detached coroutines. They use the thread pool to avoid blocking:

**Async-aware functions:**
- `read_all()` — reads entire file with `*a` pattern
- `read_chars()` — reads N bytes
- `g_write()` — writes data (single-argument case)

**Continuation Pattern:**

Each async function uses `lua_yieldk` with a continuation function:

```c
/* Example: read_all async pattern */
static int read_all_cont(lua_State *L, int status, lua_KContext ctx) {
  AsyncReadTask *task = (AsyncReadTask *)ctx;
  
  if (task->base.error) {
    /* Handle error */
    free(task);
    return luaL_error(L, "%s", task->base.error);
  }
  
  /* Push result to stack */
  lua_pushlstring(L, task->buffer, task->size);
  free(task->buffer);
  free(task);
  return 1;
}

static void read_all(lua_State *L, FILE *f) {
  if (is_detached(L)) {
    ThreadPool *pool = get_threadpool(L);
    if (pool) {
      AsyncReadTask *task = malloc(sizeof(AsyncReadTask));
      task->base.work = async_read_all_work;
      task->f = f;
      
      threadpool_submit(pool, task);
      set_yield_reason(L, YIELD_THREADPOOL);
      set_yield_task(L, task);
      
      lua_yieldk(L, 0, (lua_KContext)task, read_all_cont);
    }
  }
  
  /* Synchronous fallback */
  // ...standard fread loop...
}
```

**Worker functions** (run in thread pool):
- `async_read_all_work()` — reads entire file into malloc'd buffer
- `async_read_bytes_work()` — reads N bytes into malloc'd buffer  
- `async_write_work()` — writes data using fwrite

#### Files Created/Modified

| File | Changes |
|------|---------|
| `lev.h` | Event loop interface, yield reasons, scheduler API |
| `lev.c` | Scheduler, poll loop, async-awareness documentation |
| `lev_epoll.c` | Linux epoll backend |
| `lev_kqueue.c` | macOS/BSD kqueue backend |
| `lev_iocp.c` | Windows IOCP backend |
| `lev_select.c` | Portable select() fallback |
| `lev_threadpool.h` | Thread pool interface |
| `lev_threadpool.c` | Cross-platform thread pool |
| `lcorolib.c` | `detach`, `poll`, `pending`, `sleep`, `status_e` |
| `lnetlib.c` | Async I/O for network operations |
| `liolib.c` | Async I/O infrastructure for file operations |
| `meson.build` | Platform-specific backend selection |

## Permission System (Acquis 11)

A capability-based permission system for sandboxing Lus scripts. Permissions are granted via the `pledge()` function or CLI `--pledge`/`-P` flags.

#### Core Concepts

- **Permissions**: Named capabilities like `fs`, `exec`, `network`
- **Sub-permissions**: Fine-grained control like `fs:read`, `fs:write`, `network:http`
- **Values**: Path/URL restrictions like `fs:read=/tmp/*`
- **Seal**: Once granted, prevents new permissions
- **Rejection**: Using `~` prefix blocks future grants

#### C API

```c
/* Grant or check a permission (with optional value restriction) */
int lus_pledge(lua_State *L, const char *name, const char *value);

/* Check if permission is granted */
int lus_haspledge(lua_State *L, const char *name, const char *value);

/* Confirm a permission (used by granters) */
void lus_confirmpledge(lua_State *L, const char *name, const char *value);

/* Register a library-specific granter */
void lus_registerpledge(lua_State *L, const char *base, lus_PledgeGranter fn);

/* Get permission value count and indexed access (for granters) */
int lus_getpledgevalcount(lua_State *L, const char *name);
const char *lus_getpledgeval_i(lua_State *L, const char *name, int idx);
```

#### Helper Macro

```c
/* Build permission names with subpermissions (used by granters) */
char namebuf[LUS_PLEDGE_NAME_MAX];
LUS_PLEDGE_NAME(namebuf, "fs", subperm);  /* -> "fs" or "fs:read" */
```

#### Lua API

```lua
-- Grant permission (returns true on success, false on failure)
pledge("fs")                     -- Global fs access
pledge("fs:read=/tmp/*")         -- Restricted read access
pledge("~network")               -- Reject network permission
pledge("seal")                   -- Prevent new permissions
```

#### CLI Support

```bash
lus -Pfs script.lus              # Grant fs permission
lus --pledge=network:http script # Grant specific permission
lus -P~exec script.lus           # Pre-reject exec permission
```

#### Granter System

Libraries register granters to handle their own permission semantics:

```c
/* Example: fs granter uses glob matching for paths */
static int fs_granter(lua_State *L, int is_checking) {
  const char *subperm = lua_isstring(L, -2) ? lua_tostring(L, -2) : NULL;
  const char *path = lua_isstring(L, -1) ? lua_tostring(L, -1) : NULL;
  
  if (!is_checking) {
    /* Granting: just confirm */
    lus_confirmpledge(L, namebuf, path);
    return 1;
  }
  
  /* Checking: match path against stored glob patterns */
  int count = lus_getpledgevalcount(L, namebuf);
  if (count == 0) return 1;  /* Global access */
  
  for (int i = 0; i < count; i++) {
    const char *pattern = lus_getpledgeval_i(L, namebuf, i);
    if (pattern && lus_glob_match_path(pattern, path, 1))
      return 1;
  }
  return 0;
}

/* Registration in luaopen_fs */
lus_registerpledge(L, "fs", fs_granter);
```

#### Files Created/Modified

| File | Changes |
|------|---------|
| `lglob.h` | Glob matching API declarations |
| `lglob.c` | Path canonicalization, glob/URL matching |
| `lpledge.h` | Permission system C API |
| `lpledge.c` | Core storage, granter registry, Lua `pledge()` |
| `lstate.h` | Added `pledges` field to `lua_State` |
| `lstate.c` | Permission init/copy/free in thread lifecycle |
| `lua.c` | CLI `--pledge`/`-P` argument handling |
| `lbaselib.c` | Register `pledge` as global function |
| `lfslib.c` | fs granter with path glob matching |
| `liolib.c` | exec permission check for io.popen |
| `loslib.c` | exec permission check for os.execute |
| `lnetlib.c` | network granter with URL matching |
| `meson.build` | Added new source files, pledge test |

