# Changes between Lus and Lua

## `catch` expression

The `catch` expression is implemented as a compile-time construct that generates two new VM opcodes, with error handling integrated into `luaD_throw`.

#### New Opcodes

**`OP_CATCH` (format: iAsBx)**

- `A`: Destination register for status (results start at A+1)
- `sBx`: Signed offset to jump on error (to instruction after ENDCATCH)

Sets up a protected execution context using `setjmp`. The jump buffer is stored in `CatchInfo` (part of `CallInfo`) to persist across VM instructions.

**`OP_ENDCATCH` (format: iABC)**

- `A`: Destination register (same as OP_CATCH)
- `B`: Expected number of results + 1 (0 = LUA_MULTRET, return all)
- `C`: Jump offset to skip past error handler

Marks successful completion: sets `R[A] = true`, nil-fills if needed, restores the previous error handler, and sets `L->top` appropriately.

#### Modified Structures

**`CatchInfo`** (added to `CallInfo.u.l` in `lstate.h`):

```c
typedef struct CatchInfo {
  jmp_buf jmpbuf;                    /* setjmp buffer for error recovery */
  struct lua_longjmp *prev_errorJmp; /* saved previous error handler */
  volatile TStatus status;           /* error status (if error occurred) */
  const Instruction *errorpc;        /* PC to jump to on error */
  lu_byte destreg;                   /* destination register for status */
  lu_byte nresults;                  /* expected number of results */
  lu_byte active;                    /* 1 if catch block is active */
} CatchInfo;
```

#### Error Handling Flow

1. **Setup (OP_CATCH):**

   - Saves `L->errorJmp` to `catchinfo.prev_errorJmp`
   - Calls `setjmp(catchinfo.jmpbuf)`
   - Sets `catchinfo.active = 1`
   - Normal path: continues to next instruction

2. **Error occurs (luaD_throw modified):**

   - Walks `CallInfo` chain looking for active catch
   - If found: sets `L->ci` to catch frame, `longjmp` to catch's jmpbuf
   - Error path in OP_CATCH: restores `cl`, `k`, `base` (stale after longjmp)
   - Sets `R[A] = false`, `R[A+1] = error message`
   - Reads nresults from ENDCATCH instruction, nil-fills remaining slots
   - Jumps to `errorpc` (past ENDCATCH)

3. **Success (OP_ENDCATCH):**
   - Restores `L->errorJmp` from `prev_errorJmp`
   - Sets `R[A] = true`
   - If B=0 (MULTRET): keeps L->top from inner expression
   - Otherwise: nil-fills up to expected nresults, sets L->top
   - Continues execution

#### Catch Statement

The `catch` keyword can also be used as a statement:

```lua
catch func() -- errors are suppressed, results discarded
```

Implementation adds `catchstat()` in `lparser.c`. It uses the same opcodes but sets `OP_ENDCATCH` B=1 (0 results) and generates code to discard any values generated by the inner expression.

#### Multi-Return Implementation

For inner expressions that are multi-return (VCALL, VVARARG):

- Parser calls `luaK_setmultret()` to let inner expression return all values
- ENDCATCH's B field encodes expected result count (set by `luaK_setreturns`)
- VM nil-fills if actual returns < expected, truncates if more

#### Files Modified

| File         | Changes                                             |
| ------------ | --------------------------------------------------- |
| `llex.h`     | Added `TK_CATCH` token                              |
| `llex.c`     | Added "catch" to reserved words                     |
| `lopcodes.h` | Added `OP_CATCH`, `OP_ENDCATCH`                     |
| `lopcodes.c` | Added opmode entries (ENDCATCH uses iABC)           |
| `lopnames.h` | Added opcode names for disassembler                 |
| `ljumptab.h` | Added jump table entries                            |
| `lstate.h`   | Added `CatchInfo` struct, `#include <setjmp.h>`     |
| `lparser.h`  | Added `VCATCH` expression kind                      |
| `lparser.c`  | Added `catchexpr()`, updated `hasmultret()`         |
| `lcode.c`    | Updated `luaK_setreturns()`, `luaK_dischargevars()` |
| `ldo.c`      | Modified `luaD_throw()` to check for active catch   |
| `lvm.c`      | Implemented `OP_CATCH` and `OP_ENDCATCH` handlers   |
| `luac.c`     | Added disassembly support for new opcodes           |
| `lbaselib.c` | Removed `pcall` and `xpcall` functions              |

#### Key Implementation Details

- The `jmp_buf` must be stored in `CatchInfo` (not as a local variable) because it needs to persist across VM instruction boundaries.
- After `longjmp`, local variables in `luaV_execute` are stale. The error path must refresh `ci`, `cl`, `k`, and `base` from `L->ci`.
- Register allocation follows VCALL conventions: `freereg = base + 1` after parsing, letting `adjust_assign` handle multi-value cases.
- For multi-return inner expressions, `luaK_setmultret()` is called to preserve all return values.
- ENDCATCH reads nresults from its B field and nil-fills/truncates accordingly.
- On error, nresults is read from the ENDCATCH instruction (at errorpc - 1) for proper nil-filling.

## Assignments in `if`/`elseif` conditions

The `if`/`elseif` assignment condition feature is implemented entirely in the parser (`lparser.c`), requiring no new opcodes or VM changes. It leverages existing local variable and test instruction machinery.

#### Parser Changes

**New function `isassigncond()`:**

Detects assignment conditions by checking if the current token is `TK_NAME` and the lookahead is `=` (single equals) or `,`. This distinguishes `if a = 1 then` from `if a == 1 then`.

**New function `assigncond()`:**

Parses the assignment condition syntax: `NAME { ',' NAME } '=' explist`

1. Parses variable names using `str_checkname()`, declaring each with `new_localvar()`
2. Consumes `=` and parses expression list with `explist()`
3. Uses `adjust_assign()` to handle value count mismatches (nil-filling)
4. Activates variables with `adjustlocalvars()` (values now in registers)
5. For each variable, creates a `VNONRELOC` expression and calls `luaK_goiftrue()` to generate a `TEST` instruction
6. Chains all false-jump lists together (if ANY variable is false/nil, jump to next condition)

**Modified `test_then_block()`:**

Now checks `isassigncond()` after skipping `IF`/`ELSEIF`. If true, calls `assigncond()` instead of `cond()` for condition parsing.

**Modified `ifstat()`:**

Wraps the entire `if`/`elseif`/`else`/`end` construct in an outer `BlockCnt` scope using `enterblock()`/`leaveblock()`. This ensures:

- Variables declared in any condition remain visible through all subsequent blocks
- Variables from a failed `if` condition are accessible in `elseif` and `else` blocks
- All condition variables go out of scope when `end` is reached

#### Code Generation

For `if a, b = x, y then`:

```
EVAL x -> R[base]          ; evaluate first expression
EVAL y -> R[base+1]        ; evaluate second expression
; (variables a, b now active)
TEST R[base]               ; if a is false, jump to false_branch
JMP false_branch
TEST R[base+1]             ; if b is false, jump to false_branch
JMP false_branch
... then block ...
JMP end                    ; escape to end (if elseif/else follows)
false_branch:              ; next condition or else block
```

Each variable's truthiness is tested with `OP_TEST`. The false-jump lists are concatenated, so if ANY value is false/nil, execution jumps to the next condition.

#### Scoping Implementation

The outer block in `ifstat()` creates a scope that encompasses:

- All `if`/`elseif` condition assignments
- All `then` blocks
- The `else` block (if any)

This differs from standard Lua where each block has its own scope. The nested `block()` calls create inner scopes, but condition variables live in the outer scope and remain accessible across all branches.

#### Files Modified

| File        | Changes                                                                             |
| ----------- | ----------------------------------------------------------------------------------- |
| `lparser.c` | Added `isassigncond()`, `assigncond()`, modified `test_then_block()` and `ifstat()` |

#### Key Implementation Details

- No new tokens, opcodes, or VM changes are required
- Detection relies on lookahead: `NAME` followed by `=` or `,` indicates assignment
- Multiple variables generate multiple `TEST` instructions with chained false-jumps
- The outer `BlockCnt` ensures proper variable lifetime across the entire if statement
- Variables from earlier conditions are visible in later conditions due to shared outer scope
- Standard `adjust_assign()` handles expression count mismatches (extra variables become nil, which causes the condition to fail)

## `?` conditional (optional chaining) expression

The `?` operator enables safe navigation through potentially nil values. If the value before `?` is falsy (nil or false), subsequent suffix operations (field access, indexing, method calls, function calls) short-circuit and return the falsy value instead of raising an error.

#### Parser Changes

The implementation modifies `suffixedexp()` in `lparser.c` to handle the `?` token as a special suffix operation.

**New function `discharge2basereg()`:**

Helper function that discharges an expression to a specific register (the "base register" for the optional chain). This ensures all operations in a chain write to the same register, so when we short-circuit, the register already contains the falsy value.

**Modified `suffixedexp()`:**

Tracks two new pieces of state:

- `niljumps`: A jump list for all short-circuit exits
- `basereg`: The register holding the chain result (-1 if not in a chain)

When `?` is encountered:

1. On first `?`: Put value in a fresh register (not a local!) and record as `basereg`
2. On subsequent `?`: Discharge current expression to `basereg`
3. Emit `TEST basereg 0` followed by `JMP` to test for falsy value
4. Add the jump to `niljumps`

After each suffix operation (`.`, `[]`, `:`, `()`), if in an optional chain, discharge the result to `basereg` to maintain the single-register invariant.

At the end of `suffixedexp()`, patch all `niljumps` to the current position.

#### Code Generation

For `t?.a?.b`:

```
GETTABUP R0 _ENV "t"      ; get t
MOVE     R1 R0            ; copy to chain register R1
TEST     R1 0             ; if R1 is truthy, skip next
JMP      L1               ; jump to end if falsy
GETFIELD R1 R1 "a"        ; R1 = t.a
TEST     R1 0             ; if R1 is truthy, skip next
JMP      L1               ; jump to end if falsy
GETFIELD R1 R1 "b"        ; R1 = t.a.b
L1:                       ; result in R1
```

Key insight: All operations write to the same register (`R1`). When we jump due to a falsy value, the register already contains that value, so no explicit nil-load is needed.

#### Register Management

Critical implementation detail: The base register must be a fresh register, not a local variable's register. If we used the local's register directly, we would corrupt the local's value during the chain operations.

The `discharge2basereg()` function ensures:

1. For `VRELOC` expressions: Sets the instruction's destination to `basereg`
2. For `VNONRELOC` in different register: Emits `MOVE` to `basereg`
3. Updates `freereg` to `basereg + 1` to prevent register allocation conflicts

#### Files Modified

| File        | Changes                                                                                    |
| ----------- | ------------------------------------------------------------------------------------------ |
| `lparser.c` | Added `discharge2basereg()`, modified `suffixedexp()` to handle `?` token and track chains |

#### Key Implementation Details

- No new tokens or opcodes required; `?` is handled as ASCII value 63
- Uses existing `TEST` opcode for falsy check (nil OR false)
- When falsy, short-circuits by jumping over remaining suffix operations
- The result is the original falsy value (not explicitly nil) because the register isn't modified after the jump
- Parenthesized expressions like `(expr)?.field` work naturally because each `suffixedexp()` call has its own chain state
- Deep chains like `t?.a?.b?.c?.d?.e` are efficient: each `?` adds only `TEST` + `JMP` (2 instructions)

## `from` table deconstruction expression

The `from` keyword enables extracting multiple fields from a table using the variable names as field keys. It works with local declarations, global declarations, and regular assignments.

**Syntax:**

```lua
local a, b, c from t    -- equivalent to: local a, b, c = t.a, t.b, t.c
global a, b, c from t   -- equivalent to: global a, b, c = t.a, t.b, t.c
a, b, c from t          -- equivalent to: a, b, c = t.a, t.b, t.c
```

#### Lexer Changes

Added `TK_FROM` to the reserved words enum in `llex.h` and the corresponding "from" string in `llex.c`.

#### Parser Changes

**New function `localfrom()`:**

Handles `local NAME { ',' NAME } from expr`:

1. Reserves registers for all local variables first (`luaK_reserveregs`)
2. Parses the source table expression into the next available register
3. For each variable, generates a `GETFIELD` instruction with the variable name as key, writing directly to the reserved register slot
4. Sets `freereg` to after the local variables (dropping the temp table register)
5. Activates the local variables with `adjustlocalvars()`

**New function `globalfrom()`:**

Handles `global NAME { ',' NAME } from expr`:

Uses a recursive structure (like `initglobal`):

1. Recursively builds global variable descriptions with `buildglobal()`
2. At the base case (n == nvars): reserves registers, parses table, generates `GETFIELD` for each field
3. On the way back: calls `checkglobal()` (Lua 5.5 global checking) and `storevartop()` to store each value

**New function `assignfrom()`:**

Handles bare `NAME { ',' NAME } from expr` assignment:

1. Collects variable names from the LHS chain (stored in reverse order)
2. Reserves registers for field values
3. Parses the source table expression
4. Generates `GETFIELD` for each field into reserved registers
5. Stores each value to its variable using `storevartop()`

**Modified `restassign()`:**

- Changed return type to `int` to signal whether `from` was used
- Added `TK_FROM` case that calls `assignfrom()` and returns 1
- Outer recursive calls check return value and skip `storevartop` if inner call used `from`

**Modified `exprstat()`:**

Added `TK_FROM` to the condition that triggers assignment parsing.

**Modified `globalnames()`:**

Added `TK_FROM` case that calls `globalfrom()` instead of `initglobal()`.

**Modified `localstat()`:**

Added `TK_FROM` case that calls `localfrom()` instead of the normal initialization path.

#### Code Generation

For `local a, b, c from t`:

```
; t is in R[0]
MOVE     R[4] R[0]       ; copy table to temp register
GETFIELD R[1] R[4] "a"   ; R[1] = t.a
GETFIELD R[2] R[4] "b"   ; R[2] = t.b
GETFIELD R[3] R[4] "c"   ; R[3] = t.c
; locals a, b, c are now in R[1], R[2], R[3]
```

For `global a, b, c from t`:

```
; t is in R[0]
MOVE     R[4] R[0]       ; copy table to temp register
GETFIELD R[1] R[4] "a"   ; R[1] = t.a
GETFIELD R[2] R[4] "b"   ; R[2] = t.b
GETFIELD R[3] R[4] "c"   ; R[3] = t.c
GETTABUP R[4] _ENV "c"   ; check _ENV.c exists (Lua 5.5)
ERRNNIL  R[4] "c"
SETTABUP _ENV "c" R[3]   ; _ENV.c = R[3]
GETTABUP R[3] _ENV "b"   ; check _ENV.b exists
ERRNNIL  R[3] "b"
SETTABUP _ENV "b" R[2]   ; _ENV.b = R[2]
GETTABUP R[2] _ENV "a"   ; check _ENV.a exists
ERRNNIL  R[2] "a"
SETTABUP _ENV "a" R[1]   ; _ENV.a = R[1]
```

#### Register Management

Critical insight: After reserving registers for field values, the table expression must go into a register AFTER those reserved slots. This prevents the `freereg(fs, tblreg)` calls in `luaK_dischargevars` from corrupting the field value registers.

The pattern used:

1. `base = fs->freereg` - remember where field values will go
2. `luaK_reserveregs(fs, nvars)` - reserve slots for field values
3. Parse table, put in next register (`luaK_exp2nextreg`)
4. Generate `GETFIELD` with explicit destination registers (`base + i`)
5. Set `freereg = base + nvars` - drop temp table register

#### Files Modified

| File        | Changes                                                                                                                    |
| ----------- | -------------------------------------------------------------------------------------------------------------------------- |
| `llex.h`    | Added `TK_FROM` to reserved words enum                                                                                     |
| `llex.c`    | Added "from" to token strings array                                                                                        |
| `lparser.c` | Added `localfrom()`, `globalfrom()`, `assignfrom()`, modified `localstat()`, `globalnames()`, `restassign()`, `exprstat()` |

#### Key Implementation Details

- `from` is a new reserved word (required because it appears in statement context)
- Variable names become field keys: `local x, y from t` accesses `t.x` and `t.y`
- Fields that don't exist evaluate to `nil` (standard Lua table semantics)
- The table expression is evaluated only once (not once per field)
- Works with Lua 5.5's global declaration system (`global` keyword and checking)
- No new opcodes required; uses existing `GETFIELD` instruction

## Enums

Enums are a new type that provide symbolic constants with identity-based comparison. Each enum value belongs to an "enum root" which defines the set of valid names and their indices.

#### Type System

**New type constant in `lua.h`:**

- `LUA_TENUM = 9` - The enum base type
- `LUA_NUMTYPES` updated to 10

**Variant tags in `lobject.h`:**

- `LUA_VENUM` - User-visible enum value
- `LUA_VENUMROOT` - Internal enum root (holds name-to-index mapping)

#### Data Structures

**`EnumRoot`** (internal, not directly accessible to users):

```c
typedef struct EnumRoot {
  CommonHeader;
  int size;           /* number of enum values */
  GCObject *gclist;   /* for GC traversal */
  TString *names[1];  /* flexible array: names[0..size-1] */
} EnumRoot;
```

**`Enum`** (user-visible enum value):

```c
typedef struct Enum {
  CommonHeader;
  struct EnumRoot *root;  /* the enum definition */
  int idx;                /* 1-based index */
} Enum;
```

#### Lexer Changes

Added `TK_ENUM` to the reserved words enum in `llex.h` and the corresponding "enum" string in `llex.c`.

#### Parser Changes

**New function `enumexpr()`:**

Parses `enum NAME { ',' NAME } end`:

1. Skips `TK_ENUM`
2. Collects all names into an array using `str_checkname()`
3. Creates the EnumRoot with `luaE_newroot()`
4. Creates the first enum value with `luaE_new()`
5. Adds the enum value as a constant with `luaK_enumK()`
6. Returns expression pointing to the constant

**Modified `simpleexp()`:**

Added `TK_ENUM` case that calls `enumexpr()`.

#### Code Generation

For `local a = enum x, y, z end`:

```
LOADK    R[0] K[0]     ; K[0] is the first enum value (index 1)
; (local 'a' is now in R[0])
```

The enum root and first value are created at compile time and stored as constants.

#### VM Changes

**Enum Indexing:**

When indexing an enum value:

1. **By string**: Look up the name in the root's `names` array. If found, create/return an enum value with that index. If not found, error.

2. **By integer**: Check bounds (1 to size). If valid, create/return an enum value with that index. If invalid, error.

**Modified `luaV_finishget()`:**

Added handling for `LUA_TENUM` type to perform enum-specific indexing.

#### Garbage Collection

**Traversal (`lgc.c`):**

- `traverseenum()`: Marks the enum's root
- `traverseenumroot()`: Marks all name strings in the root

**Freeing:**

- `freeobj()` updated to handle `LUA_VENUM` and `LUA_VENUMROOT`
- EnumRoot frees its names array
- Enum values are simple fixed-size allocations

#### C API

**New functions in `lapi.c`:**

```c
/* Push an enum onto the stack from pairs on the stack.
** Usage: push string/number pairs, then call lua_pushenum(L, npairs).
** Example:
**   lua_pushstring(L, "foo");
**   lua_pushinteger(L, 1);
**   lua_pushstring(L, "bar");
**   lua_pushinteger(L, 2);
**   lua_pushenum(L, 2);  // creates enum{foo=1, bar=2}, pushes foo
*/
LUA_API void lua_pushenum (lua_State *L, int npairs);

/* Check if value at index is an enum */
LUA_API int lua_isenum (lua_State *L, int idx);

/* Get the integer index of an enum value (1-based) */
LUA_API lua_Integer lua_toenumidx (lua_State *L, int idx);
```

**Updated functions:**

- `lua_type()`: Returns `LUA_TENUM` for enum values
- `lua_typename()`: Returns "enum" for `LUA_TENUM`

#### Base Library Changes

**`tonumber()`:**

Updated to handle enums: returns the 1-based index of the enum value.

**`type()`:**

Returns "enum" for enum values (automatic via `lua_typename`).

#### Comparison Semantics

- **Equality (`==`, `~=`)**: Two enum values are equal only if they have the same root AND the same index.
- **Ordering (`<`, `<=`, `>`, `>=`)**: Enums compare by their numeric indices (allows `enum_a.x < enum_a.y`).
- **Cross-enum comparison**: Different enum roots are never equal, but ordering comparison between them raises an error (or compares by index, TBD).

#### Files Modified/Created

| File          | Changes                                                             |
| ------------- | ------------------------------------------------------------------- |
| `lua.h`       | Added `LUA_TENUM`, updated `LUA_NUMTYPES`                           |
| `lobject.h`   | Added `LUA_VENUM`, `LUA_VENUMROOT`, Enum/EnumRoot structs, macros   |
| `lstate.h`    | Added Enum/EnumRoot to GCUnion, gco2enum/gco2enumroot macros        |
| `lenum.h`     | **NEW**: Enum function declarations                                 |
| `lenum.c`     | **NEW**: Enum implementation                                        |
| `llex.h`      | Added `TK_ENUM` to reserved words enum                              |
| `llex.c`      | Added "enum" to token strings                                       |
| `ltm.c`       | Added "enum" to type names array                                    |
| `lgc.c`       | Added traverseenum, traverseenumroot, updated freeobj/propagatemark |
| `lparser.c`   | Added `enumexpr()`, updated `simpleexp()`                           |
| `lcode.c`     | Added `luaK_enumK()` for enum constants                             |
| `lvm.c`       | Updated `luaV_finishget()` for enum indexing                        |
| `lapi.c`      | Added `lua_pushenum()`, `lua_isenum()`, `lua_toenumidx()`           |
| `lbaselib.c`  | Updated `tonumber` to handle enums                                  |
| `meson.build` | Added `lenum.c` to sources                                          |

#### Key Implementation Details

- Enum roots are created at parse time and stored as constants in the function prototype
- All enum values in a family share the same root pointer (identity comparison)
- The root's `names` array is allocated inline using flexible array member
- Enum indexing by string is O(n) for simplicity; could be optimized with hash lookup
- No new opcodes required; enum indexing uses existing `GETTABLE`/`GETFIELD` paths with type-specific handling in `luaV_finishget()`
- Cross-enum ordering comparisons error (different "types" of enums shouldn't be compared for order)

## JSON

Lus adds RFC 8259 compliant `tojson` and `fromjson` global functions for JSON serialization and deserialization. [Tested against 369 RFC 8259 test files (95 valid, 188 invalid, 86 implementation-defined)](https://github.com/nst/JSONTestSuite).

#### API

**`fromjson(json_string)`**

- Parses JSON string into Lua value
- Returns: `table`, `string`, `number`, `boolean`, or `nil`
- Throws error on invalid JSON with position information

**`tojson(value, [filter])`**

- Serializes Lua value to compact JSON string
- Optional `filter(key, value)` callback for transformation/filtering
- Returns `nil` from filter to omit a property
- `__json` metamethod: if present, called with `self`, return value is serialized instead

#### Implementation

The implementation is in `ljsonlib.c` with an iterative state-machine parser and recursive serializer.

**Parser Features:**

- All JSON types: strings, numbers, booleans, null, arrays, objects
- Escape sequences: `\"`, `\\`, `\/`, `\b`, `\f`, `\n`, `\r`, `\t`, `\uXXXX`
- Surrogate pair handling for supplementary Unicode characters
- Clear error messages with byte position
- Iterative design using direct object manipulation (no Lua stack overflow)

**Serializer Features:**

- Automatic array vs object detection (contiguous 1..n integer keys = array)
- `inf`/`-inf`/`nan` serialized as `null` (per RFC 8259)
- Cycle detection with error on circular references
- Skips unsupported types: functions, threads, enums, userdata (without `__json`)

#### Files Created/Modified

| File          | Changes                                           |
| ------------- | ------------------------------------------------- |
| `ljsonlib.c`  | **NEW**: JSON parser and serializer (~1030 lines) |
| `lualib.h`    | Added `luaopen_json` declaration                  |
| `linit.c`     | Call `luaopen_json()` to register globals         |
| `meson.build` | Added `ljsonlib.c` to lib_sources                 |

## Filesystem Library (`fs`)

Lus introduces a dedicated `fs` library for filesystem operations, fixing cross-platform inconsistencies in the standard `os` library and adding missing features like directory listing, recursive removal, and symlink handling.

#### Design

The `fs` library is implemented in C (`lfslib.c`) and exposed as a global `fs` table. It prioritizes cross-platform consistency (Windows vs POSIX) while providing access to platform-specific needs where unavoidable (e.g., path separators).

**Removed Functions:**

- `os.remove`
- `os.rename`

(These are superseded by `fs.remove` and `fs.move`).

#### API

**File Operations:**

- `fs.list(dir, [glob])`: Returns an array of filenames in `dir`. Supports basic glob patterns (`*`, `?`).
- `fs.copy(src, dst)`: Copies file `src` to `dst`.
- `fs.move(src, dst)`: Moves/renames `src` to `dst`.
- `fs.remove(path, [recursive])`: Removes file or directory. Recursive if second arg is true.
- `fs.type(path)`: Returns "file", "directory", or raises error. Returns second value boolean `is_link`.
- `fs.createdirectory(path, [recursive])`: Creates a new directory. If `recursive` is true, creates parent directories as needed.

**Symlinks:**

- `fs.createlink(linkname, target)`: Creates a symbolic link.
- `fs.follow(path)`: Resolves a symlink to its target path. (On Windows, implemented via `GetFinalPathNameByHandle`).

**Path Manipulation (`fs.path`):**

- `fs.path.join(...)`: Joins path components with platform separator.
- `fs.path.split(path)`: Splits path into components.
- `fs.path.name(path)`: Returns the filename part.
- `fs.path.parent(path)`: Returns the parent directory part.
- `fs.path.separator`: `/` or `\`
- `fs.path.delimiter`: `:` or `;`

#### Implementation Details

- **Cross-Platform**: Uses `#if defined(LUS_PLATFORM_WINDOWS)` to select between Win32 API (`FindFirstFile`, `CopyFile`, `GetFinalPathNameByHandle`) and POSIX (`opendir`, `sendfile` fallback, `readlink`)
- **Recursive Remove**: Implemented manually to handle directory traversal and file deletion safely on both platforms.
- **Symlinks on Windows**: `fs.follow` extracts the final path and strips the `\\?\` prefix if present.

#### Files Modified

| File          | Changes                              |
| ------------- | ------------------------------------ |
| `lfslib.c`    | **NEW**: `fs` library implementation |
| `loslib.c`    | Removed `os.remove` and `os.rename`  |
| `linit.c`     | Registered `fs` library              |
| `lualib.h`    | Added `luaopen_fs`                   |
| `meson.build` | Added `lfslib.c` to build sources    |

## `string.transcode`

Lus adds a universal encoding transcoding function to the string library, enabling conversion between various text encodings and binary-to-text formats.

#### API

**`string.transcode(data, from, to [, ignorebad])`**

Transcodes the input string from the source encoding to the destination encoding.

**Parameters:**

- `data`: The input string (raw byte buffer)
- `from`: Source encoding name (string)
- `to`: Target encoding name (string)
- `ignorebad`: Optional boolean. If true, silently skips invalid/untranscodable characters instead of raising an error

**Returns:** The transcoded string

**Throws:** Error if encoding is invalid or data cannot be transcoded (unless `ignorebad` is true)

#### Supported Encodings

| Encoding     | Description                                                           |
| ------------ | --------------------------------------------------------------------- |
| `ascii`      | 7-bit ASCII (bytes 0-127)                                             |
| `utf-8`      | Standard UTF-8                                                        |
| `utf-8bom`   | UTF-8 with Byte Order Mark (strips BOM on decode, adds BOM on encode) |
| `utf-16le`   | Little-endian UTF-16 (with surrogate pair support)                    |
| `iso-8859-1` | Latin-1 single-byte encoding (alias: `latin-1`)                       |
| `base64`     | Base64 binary-to-text encoding                                        |
| `url`        | URL encoding                                                          |
| `hex`        | Hexadecimal representation                                            |

#### Encoding Categories

**Character-based encodings** (`ascii`, `utf-8`, `utf-8bom`, `utf-16le`, `iso-8859-1`):

- Transcode via Unicode codepoints
- Characters that cannot be represented in the target encoding trigger an error (or are skipped with `ignorebad`)

**Binary-to-text encodings** (`base64`, `url`, `hex`):

- When used as `from`: Decode the formatted string to raw bytes
- When used as `to`: Encode raw bytes to the formatted string
- Can be chained (e.g., `base64` → `hex` decodes base64 to bytes, then encodes as hex)

#### Implementation Details

**UTF-16LE Endianness:**

The implementation explicitly handles byte order rather than relying on host architecture:

```c
/* Reading UTF-16LE (always little-endian) */
static l_uint32 read_utf16le(const unsigned char *p) {
  return (l_uint32)p[0] | ((l_uint32)p[1] << 8);
}

/* Writing UTF-16LE (always little-endian) */
static void write_utf16le(unsigned char *p, l_uint32 val) {
  p[0] = (unsigned char)(val & 0xFF);
  p[1] = (unsigned char)((val >> 8) & 0xFF);
}
```

**Surrogate Pair Handling:**

UTF-16LE correctly handles supplementary plane characters (U+10000 to U+10FFFF) via surrogate pairs:

- Encoding: Codepoints > U+FFFF are split into high (0xD800-0xDBFF) and low (0xDC00-0xDFFF) surrogates
- Decoding: Surrogate pairs are combined back into the original codepoint
- Lone surrogates trigger an error

**UTF-8 BOM:**

- Decoding `utf-8bom`: Strips the 3-byte BOM (EF BB BF) if present at the start
- Encoding to `utf-8bom`: Prepends the BOM to the output

**URL Encoding:**

- Encodes all bytes except unreserved characters (A-Z, a-z, 0-9, `-`, `_`, `.`, `~`)
- Decodes `%XX` hex sequences and `+` (as space)

**Base64:**

- RFC 4648 standard alphabet (`A-Za-z0-9+/` with `=` padding)
- Ignores whitespace during decoding

#### Example Usage

```lua
-- Base64 decoding
local raw = string.transcode("dXNlcjpwYXNzd29yZA==", "base64", "utf-8")
print(raw) -- "user:password"

-- URL encoding
local safe = string.transcode("hello world & others", "utf-8", "url")
print(safe) -- "hello%20world%20%26%20others"

-- Hex dump
local hex = string.transcode("Lus", "utf-8", "hex")
print(hex) -- "4c7573"

-- UTF-8 to UTF-16LE
local utf16 = string.transcode("Hello", "utf-8", "utf-16le")
-- utf16 == "H\0e\0l\0l\0o\0"

-- Character set conversion with fallback
local latin = string.transcode("日本語", "utf-8", "iso-8859-1", true)
print(latin) -- "" (characters skipped, cannot be represented)
```

#### Files Modified

| File        | Changes                                             |
| ----------- | --------------------------------------------------- |
| `lstrlib.c` | Added `str_transcode` and encoding helper functions |

## `network` Library

The `network` library provides native TCP, UDP, and HTTP/HTTPS networking capabilities through a new source file `lnetlib.c`.

#### External Dependencies

- **OpenSSL**: Required for HTTPS/TLS support
- **c-ares**: Async DNS resolution library

#### Platform Abstraction

Cross-platform socket abstraction using preprocessor directives:

```c
#if defined(LUS_PLATFORM_WINDOWS)
  typedef SOCKET socket_t;
  #define sock_close closesocket
  // Winsock initialization via WSAStartup
#else
  typedef int socket_t;
  #define sock_close close
  // POSIX sockets (Linux, macOS, BSD)
#endif
```

#### Userdata Types

Three userdata types with metatables:

| Type | Metatable | Description |
|------|-----------|-------------|
| `LSocket` | `network.socket` | TCP client connection |
| `LServer` | `network.server` | TCP listening server |
| `LUDPSocket` | `network.udpsocket` | UDP datagram socket |

Each includes `__gc`, `__close`, and `__tostring` metamethods.

#### API Functions

**TCP:**
- `network.tcp.connect(address, port)` → Socket
- `network.tcp.bind(address, port, [backlog])` → Server
- `socket:send(data)`, `socket:receive([pattern])`, `socket:close()`, `socket:settimeout(sec)`
- `server:accept()`, `server:close()`, `server:settimeout(sec)`

**UDP:**
- `network.udp.open([port], [address])` → UDPSocket
- `udp:sendto(data, addr, port)`, `udp:receive([size])`, `udp:close()`

**HTTP:**
- `network.fetch(url, [method], [headers], [body])` → status, body, headers

#### DNS Resolution

Uses c-ares `ares_getaddrinfo()` for async-capable DNS lookups supporting IPv4/IPv6.

#### TLS/HTTPS

OpenSSL integration for secure connections:
- `SSL_CTX` created once at library init
- `SSL_connect()` for handshake, `SSL_read()`/`SSL_write()` for I/O
- Certificate verification via system CA certificates

#### Files Modified

| File | Changes |
|------|---------|
| `lnetlib.c` | NEW - Full network library implementation (~1600 lines) |
| `linit.c` | Register `luaopen_network` in stdlibs |
| `lualib.h` | Add `LUA_NETLIBNAME`, `LUA_NETLIBK`, `luaopen_network` |
| `meson.build` | Add `lnetlib.c`, OpenSSL/c-ares deps, Winsock for Windows |

#### ~~Async I/O for Event Loop~~ (REMOVED)

> **Note:** The event loop and async I/O functionality has been **removed**. All network operations are now synchronous/blocking. The `coroutine.detach`, `coroutine.run`, `coroutine.poll`, `coroutine.pending`, and `coroutine.sleep` functions no longer exist. The standard Lua 5.5 coroutine library has been restored.

**Network operations are purely synchronous:**
- `socket:send()` - Blocks until all data is sent
- `socket:receive()` - Blocks until data is received
- `server:accept()` - Blocks until a connection arrives
- `network.connect()` - Blocks until connected or error

## ~~Event Loop~~ (REMOVED)

The event loop has been **completely removed** from Lus. This includes:

- **Removed files:** `ltask.c`, `ltask.h`, `lev.c`, `lev.h`, `lev_kqueue.c`, `lev_epoll.c`, `lev_threadpool.c`
- **Removed coroutine functions:** `detach`, `run`, `poll`, `pending`, `sleep`
- **Removed from `global_State`:** `scheduler` field
- **Restored:** Standard Lua 5.5 coroutine library (`lcorolib.c`)

The rationale for removal was to simplify the codebase and focus on synchronous I/O. Applications requiring async I/O should use Lua coroutines with explicit polling or integrate with an external event loop.




## Permission System

A capability-based permission system for Lus scripts. Permissions are granted via the `pledge()` function or CLI `--pledge`/`-P` flags.

#### Core Concepts

- **Permissions**: Named capabilities like `fs`, `exec`, `network`, `load`
- **Sub-permissions**: Fine-grained control like `fs:read`, `fs:write`, `network:http`, `network:udp`
- **Values**: Path/URL restrictions like `fs:read=/tmp/*`
- **Seal**: Once granted, prevents new permissions
- **Rejection**: Using `~` prefix blocks future grants

#### Lua API

```lua
-- Grant permissions (returns true on success, false on failure)
pledge("fs")                     -- Global fs access
pledge("fs:read=/tmp/*")         -- Restricted read access
pledge("load", "fs:read")        -- Multiple permissions
pledge("~network")               -- Reject network permission
pledge("seal")                   -- Prevent new permissions
```

#### CLI Support

```bash
lus -Pfs script.lus              # Grant fs permission
lus --pledge network:http script # Grant specific permission
lus -P~exec script.lus           # Pre-reject exec permission
```

#### Data Structures

**`lus_PledgeRequest`** — Request structure passed to granter callbacks:

```c
typedef struct lus_PledgeRequest {
  const char *base;     /* "fs", "network", etc. */
  const char *sub;      /* "read", "tcp", or NULL */
  const char *value;    /* requested value, or NULL */
  const char *current;  /* current stored value during iteration */
  int status;           /* LUS_PLEDGE_GRANT, UPDATE, or CHECK */
  int count;            /* number of stored values */
  int has_base;         /* 1 if base permission already granted */
} lus_PledgeRequest;
```

**`lus_PledgeGranter`** — Granter callback signature:

```c
typedef void (*lus_PledgeGranter)(lua_State *L, lus_PledgeRequest *p);
```

#### C API

| Function | Description |
|----------|-------------|
| `lus_pledge(L, name, value)` | Grant a permission |
| `lus_haspledge(L, name, value)` | Check if permission is granted |
| `lus_registerpledge(L, base, fn)` | Register a granter for a permission namespace |
| `lus_initpledge(L, &p, base)` | Initialize request for C-side grants |
| `lus_nextpledge(L, &p)` | Iterate stored values, sets `p->current` |
| `lus_setpledge(L, &p, sub, value)` | Confirm/store a pledge |
| `lus_rejectpledge(L, name)` | Permanently reject a permission |
| `lus_rejectrequest(L, &p)` | Reject using request struct |
| `lus_pledgeerror(L, &p, msg)` | Set denial error message |
| `lus_issealed(L)` | Check if sealed |
| `lus_checkfsperm(L, perm, path)` | Check fs permission or raise error |

#### Granter System

Libraries register granters to handle their own permission semantics:

```c
static void fs_granter(lua_State *L, lus_PledgeRequest *p) {
  /* Granting: validate and store */
  if (p->status == LUS_PLEDGE_GRANT || p->status == LUS_PLEDGE_UPDATE) {
    if (p->sub == NULL) {
      lus_setpledge(L, p, NULL, p->value);
    } else if (strcmp(p->sub, "read") == 0 || strcmp(p->sub, "write") == 0) {
      lus_setpledge(L, p, p->sub, p->value);
    } else {
      luaL_error(L, "unknown fs subpermission: '%s'", p->sub);
    }
    return;
  }
  
  /* Checking: match path against stored glob patterns */
  if (p->status == LUS_PLEDGE_CHECK) {
    while (lus_nextpledge(L, p)) {
      if (lus_glob_match_path(p->current, p->value, 1)) {
        lus_setpledge(L, p, p->sub, NULL);
        return;
      }
    }
  }
}

/* Registration in luaopen_fs */
lus_registerpledge(L, "fs", fs_granter);
```

#### Files Created/Modified

| File | Changes |
|------|---------|
| `lglob.h` | Glob matching API declarations |
| `lglob.c` | Path canonicalization, glob/URL matching |
| `lpledge.h` | Permission system C API, `lus_PledgeRequest` struct |
| `lpledge.c` | Core storage, granter registry, Lua `pledge()` |
| `lstate.h` | Added `pledges` field to `lua_State` |
| `lstate.c` | Permission init/copy/free in thread lifecycle |
| `lua.c` | CLI `--pledge`/`-P` argument handling |
| `lbaselib.c` | Register `pledge` as global, `load`/`exec` granters |
| `lfslib.c` | fs granter with path glob matching |
| `liolib.c` | exec permission check for io.popen |
| `loslib.c` | exec permission check for os.execute |
| `lnetlib.c` | network granter with URL matching |
| `loadlib.c` | fs:read + load permission checks for require |
| `meson.build` | Added new source files, pledge test |







