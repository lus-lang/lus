---

---

<!-- Environment Functions -->
<h2 id="pledge">pledge (name...)</h2>
<p>
  Grants or checks a permission. Returns <code>true</code> if the permission was granted,
  <code>false</code> if it was denied or the state is sealed.
</p>
<p>
  The <code>name</code> arguments specify the permissions to grant or check.
</p>
<p>
  Special permissions: <code>"all"</code> grants all permissions (CLI only),
  <code>"seal"</code> prevents future permission changes. The <code>~</code> prefix
  rejects a permission permanently.
</p>
<pre><code>pledge("fs")           -- grant filesystem access
pledge("fs:read=/tmp") -- grant read access to /tmp only
pledge("~network")     -- reject network permission
pledge("seal")         -- lock permissions</code></pre>

<!-- C API Types -->

<h2 id="lus_PledgeRequest">lus_PledgeRequest</h2>
<pre><code>{`typedef struct lus_PledgeRequest {
  const char *base;     /* "fs", "network", etc. */
  const char *sub;      /* "read", "tcp", or NULL */
  const char *value;    /* requested value, or NULL */
  const char *current;  /* current stored value during iteration */
  int status;           /* LUS_PLEDGE_GRANT, UPDATE, or CHECK */
  int count;            /* number of stored values */
  int has_base;         /* 1 if base permission already granted */
} lus_PledgeRequest;`}</code></pre>
<p>
  Request structure passed to granter callbacks. Contains all information about
  the permission being granted or checked.
</p>
<p>
  <code>status</code> indicates the operation: <code>LUS_PLEDGE_GRANT</code> for new
  grants,
  <code>LUS_PLEDGE_UPDATE</code> for updates, <code>LUS_PLEDGE_CHECK</code> for access
  checks.
</p>

<h2 id="lus_PledgeGranter">lus_PledgeGranter</h2>
<pre><code>typedef void (*lus_PledgeGranter)(lua_State *L, lus_PledgeRequest *p);</code></pre>
<p>
  Callback type for permission granters. Libraries register granters to handle
  their own permission validation logic.
</p>
<p>
  Granters should call <code>lus_setpledge</code> to confirm valid permissions. Unprocessed
  requests are automatically denied. For invalid subpermissions, use <code
    >luaL_error</code
  > to report an error.
</p>

<!-- Status Constants -->

<h2 id="LUS_PLEDGE_GRANT">Status Constants</h2>
<pre><code>#define LUS_PLEDGE_GRANT  0  /* New permission request */
#define LUS_PLEDGE_UPDATE 1  /* Updating existing permission */
#define LUS_PLEDGE_CHECK  2  /* Read-only permission check */</code></pre>
<p>
  Values for <code>lus_PledgeRequest.status</code>. Granters should handle
  GRANT/UPDATE for permission grants and CHECK for access checks.
</p>

<!-- Iterator Functions -->

<h2 id="lus_initpledge">lus_initpledge</h2>
<pre><code>void lus_initpledge(lua_State *L, lus_PledgeRequest *p, const char *base);</code></pre>
<p>
  Initializes a pledge request for C-side grants. This bypasses granters and is
  used for direct permission grants from C code.
</p>
<pre><code>{`lus_PledgeRequest p;
lus_initpledge(L, &p, "fs");
lus_setpledge(L, &p, "read", "/tmp/*");`}</code></pre>

<h2 id="lus_nextpledge">lus_nextpledge</h2>
<pre><code>int lus_nextpledge(lua_State *L, lus_PledgeRequest *p);</code></pre>
<p>
  Iterates through stored values for a permission. Sets <code
    >p-&gt;current</code
  >
  to the next stored value.
</p>
<p>
  Returns <code>1</code> if there are more values, <code>0</code> when done.
</p>
<pre><code>{`while (lus_nextpledge(L, p)) {
  if (match(p->current, p->value))
    lus_setpledge(L, p, p->sub, NULL);
}`}</code></pre>

<h2 id="lus_setpledge">lus_setpledge</h2>
<pre><code>void lus_setpledge(lua_State *L, lus_PledgeRequest *p,
                   const char *sub, const char *value);</code></pre>
<p>
  Confirms or sets a pledge value. Marks the request as processed, preventing
  automatic denial. Must be called by granters to approve a permission.
</p>
<p>
  <code>sub</code> is the subpermission (e.g., "read") or NULL for base.
  <code>value</code> is the value to store (e.g., path) or NULL for unrestricted.
</p>

<h2 id="lus_rejectrequest">lus_rejectrequest</h2>
<pre><code>void lus_rejectrequest(lua_State *L, lus_PledgeRequest *p);</code></pre>
<p>
  Permanently rejects a permission using the request struct. Future attempts to
  grant this permission will fail.
</p>

<h2 id="lus_pledgeerror">lus_pledgeerror</h2>
<pre><code>void lus_pledgeerror(lua_State *L, lus_PledgeRequest *p, const char *msg);</code></pre>
<p>
  Sets a denial error message for user-facing feedback. Called by granters to
  explain why a permission was denied.
</p>

<!-- Public API Functions -->

<h2 id="lus_pledge">lus_pledge</h2>
<pre><code>int lus_pledge(lua_State *L, const char *name, const char *value);</code></pre>
<p>
  Grants a permission to the Lua state. Triggers the granter callback for
  validation. Returns <code>1</code> on success, <code>0</code> if denied or sealed.
</p>
<p>
  Throws an error if the permission name is not recognized (no granter
  registered).
</p>

<h2 id="lus_haspledge">lus_haspledge</h2>
<pre><code>int lus_haspledge(lua_State *L, const char *name, const char *value);</code></pre>
<p>
  Checks if a permission has been granted. The <code>value</code> argument specifies
  the resource being accessed (e.g., a file path).
</p>
<p>
  Returns <code>1</code> if access is allowed, <code>0</code> if denied.
</p>

<h2 id="lus_registerpledge">lus_registerpledge</h2>
<pre><code>void lus_registerpledge(lua_State *L, const char *base, lus_PledgeGranter fn);</code></pre>
<p>
  Registers a granter callback for a permission namespace. Call this in your
  library's <code>luaopen_*</code> function.
</p>
<pre><code>{`static void my_granter(lua_State *L, lus_PledgeRequest *p) {
  if (p->status == LUS_PLEDGE_CHECK) {
    lus_setpledge(L, p, p->sub, NULL);  /* allow */
  } else {
    lus_setpledge(L, p, p->sub, p->value);  /* grant */
  }
}

LUAMOD_API int luaopen_mylib(lua_State *L) {
  lus_registerpledge(L, "mylib", my_granter);
  /* ... */
}`}</code></pre>

<h2 id="lus_rejectpledge">lus_rejectpledge</h2>
<pre><code>int lus_rejectpledge(lua_State *L, const char *name);</code></pre>
<p>
  Permanently rejects a permission by name (string-based version). Returns <code
    >1</code
  > on success, <code>0</code> if sealed.
</p>

<h2 id="lus_revokepledge">lus_revokepledge</h2>
<pre><code>int lus_revokepledge(lua_State *L, const char *name);</code></pre>
<p>
  Revokes a previously granted permission. Clears all stored values for the
  permission. Returns <code>1</code> on success, <code>0</code> if sealed or not found.
</p>

<h2 id="lus_issealed">lus_issealed</h2>
<pre><code>int lus_issealed(lua_State *L);</code></pre>
<p>
  Returns <code>1</code> if the permission state is sealed, <code>0</code> otherwise.
  When sealed, no new permissions can be granted or rejected.
</p>

<h2 id="lus_checkfsperm">lus_checkfsperm</h2>
<pre><code>int lus_checkfsperm(lua_State *L, const char *perm, const char *path);</code></pre>
<p>
  Convenience function for filesystem permission checks. Checks if <code
    >perm</code
  >
  (e.g., "fs:read") is granted for <code>path</code>. Raises an error if denied.
</p>
<pre><code>lus_checkfsperm(L, "fs:read", "/etc/passwd");  /* error if denied */</code></pre>

<!-- Worker Library -->

<h2 id="worker.create">worker.create (path, ...)</h2>
<p>
  Spawns a new worker running the script at <code>path</code>. Optional varargs
  are serialized and can be received by the worker via <code>worker.peek()</code
  >. Returns a worker handle. Requires <code>load</code> and <code>fs:read</code
  > pledges.
</p>
<pre><code>{`local w = worker.create("worker.lus", "hello", 42)
-- worker can receive "hello" and 42 via worker.peek()`}</code></pre>

<h2 id="worker.status">worker.status (w)</h2>
<p>
  Returns the status of worker <code>w</code>: <code>"running"</code> if the worker
  is still executing, or <code>"dead"</code> if it has finished or errored.
</p>

<h2 id="worker.receive">worker.receive (w1, ...)</h2>
<p>
  Blocking select-style receive from one or more workers. Blocks until at least
  one worker has a message. Returns one value per worker: the message if
  available, or <code>nil</code> if that worker has no message. Propagates worker
  errors.
</p>
<pre><code>{`local msg = worker.receive(w)
-- or multi-worker select:
local m1, m2 = worker.receive(w1, w2)`}</code></pre>

<h2 id="worker.send">worker.send (w, value)</h2>
<p>
  Sends <code>value</code> to worker <code>w</code>'s inbox. The worker can
  receive it via <code>worker.peek()</code>. Values are deep-copied.
</p>

<h2 id="worker.message">worker.message (value)</h2>
<p>
  <em>(Worker-side only)</em> Sends <code>value</code> to the worker's outbox for
  the parent to receive via <code>worker.receive()</code>.
</p>

<h2 id="worker.peek">worker.peek ()</h2>
<p>
  <em>(Worker-side only)</em> Blocking receive from the worker's inbox. Blocks until
  a message from the parent (via <code>worker.send()</code>) is available.
</p>

<!-- Worker C API -->

<h2 id="lus_WorkerSetup">lus_WorkerSetup</h2>
<pre><code>typedef void (*lus_WorkerSetup)(lua_State *parent, lua_State *worker);</code></pre>
<p>
  Callback type for worker state initialization. Called when a new worker is
  created, allowing embedders to configure the worker's Lua state (e.g., open
  libraries).
</p>

<h2 id="lus_onworker">lus_onworker</h2>
<pre><code>void lus_onworker(lua_State *L, lus_WorkerSetup fn);</code></pre>
<p>
  Registers a callback to be invoked when new worker states are created.
  Typically used to open libraries in worker states.
</p>
<pre><code>{`static void worker_setup(lua_State *parent, lua_State *worker) {
  luaL_openlibs(worker);
}
lus_onworker(L, worker_setup);`}</code></pre>

<h2 id="lus_worker_pool_init">lus_worker_pool_init</h2>
<pre><code>void lus_worker_pool_init(lua_State *L);</code></pre>
<p>
  Initializes the global worker thread pool. Called automatically on first
  <code>worker.create()</code>. M = number of CPU cores (capped at 32).
</p>

<h2 id="lus_worker_pool_shutdown">lus_worker_pool_shutdown</h2>
<pre><code>void lus_worker_pool_shutdown(void);</code></pre>
<p>Shuts down the worker thread pool. Waits for all threads to complete.</p>

<h2 id="luaopen_worker">luaopen_worker</h2>
<pre><code>int luaopen_worker(lua_State *L);</code></pre>
<p>
  Opens the worker library. Called automatically by <code>luaL_openlibs</code>.
</p>

<!-- Debug Library -->

<h2 id="debug.parse">debug.parse (code, [chunkname])</h2>
<p>
  Parses a Lus source string and returns its AST (Abstract Syntax Tree) as a
  nested table structure. Returns <code>nil</code> if parsing fails.
</p>
<p>
  The optional <code>chunkname</code> argument specifies the name used in error messages
  (defaults to <code>"=(parse)"</code>).
</p>
<pre><code>{`local ast = debug.parse("local x = 1 + 2")
-- Returns: {type = "chunk", line = 1, children = {...}}

-- With custom chunk name
local ast = debug.parse(code, "myfile.lus")`}</code></pre>
<p>
  Each AST node is a table with at minimum <code>type</code> (node type string) and
  <code>line</code> (source line number). Additional fields depend on node type. See
  <a href="/manual/acquis-12">Acquis 12</a> for details.
</p>

<!-- Vector Library -->

<h2 id="vector.create">vector.create (capacity [, fast])</h2>
<p>
  Creates a new vector with the given <code>capacity</code> in bytes. If <code>fast</code>
  is true, the buffer is not zero-initialized (faster but contents are undefined).
</p>
<pre><code>{`local v = vector.create(1024)        -- zero-initialized
local v = vector.create(1024, true)  -- fast, uninitialized`}</code></pre>

<h2 id="vector.pack">vector.pack (v, offset, fmt, ...)</h2>
<p>
  Packs values into the vector <code>v</code> starting at <code>offset</code>.
  Uses the same format string as <code>string.pack</code>.
</p>
<pre><code>{`local v = vector.create(16)
vector.pack(v, 0, "I4I4I4", 1, 2, 3)`}</code></pre>

<h2 id="vector.unpack">vector.unpack (v, offset, fmt)</h2>
<p>
  Unpacks values from the vector <code>v</code> starting at <code>offset</code>.
  Uses the same format string as <code>string.unpack</code>. Returns unpacked values
  followed by the next offset.
</p>
<pre><code>{`local a, b, c, nextpos = vector.unpack(v, 0, "I4I4I4")`}</code></pre>

<h2 id="vector.clone">vector.clone (v)</h2>
<p>
  Creates a copy of the vector <code>v</code>.
</p>

<h2 id="vector.size">vector.size (v)</h2>
<p>
  Returns the size of the vector in bytes. Equivalent to <code>#v</code>.
</p>

<h2 id="vector.resize">vector.resize (v, newsize)</h2>
<p>
  Resizes the vector to <code>newsize</code> bytes. New bytes are zero-initialized.
  Existing data within the new size is preserved.
</p>

<h2 id="vector.unpackmany">vector.unpackmany (v, offset, fmt [, count])</h2>
<p>
  Returns an iterator that repeatedly unpacks values from <code>v</code> using the format
  <code>fmt</code>. Optional <code>count</code> limits the number of iterations.
</p>
<pre><code>{`for a, b in vector.unpackmany(v, 0, "I4I4") do
  print(a, b)
end`}</code></pre>

<!-- Table Library Additions -->

<h2 id="table.clone">table.clone (t [, deep])</h2>
<p>
  Creates a copy of the table <code>t</code>. If <code>deep</code> is true, nested tables
  are recursively cloned. Deep copies preserve circular references.
</p>
<pre><code>{`local x = table.clone(t)        -- shallow copy
local y = table.clone(t, true)  -- deep copy

-- Circular references preserved
local t = {}
t.a = t
local c = table.clone(t, true)
assert(c.a == c)`}</code></pre>

<!-- Metamethods -->

<h2 id="__slice">__slice</h2>
<p>
  The <code>__slice</code> metamethod is called when the slice operator is used on a table.
  It receives the table, start index, and end index (which may be nil).
</p>
<pre><code>{`local mt = {
  __slice = function(self, start, finish)
    return {start = start, finish = finish}
  end
}
local x = setmetatable({}, mt)
local result = x[5, 10]  -- calls __slice(x, 5, 10)`}</code></pre>
