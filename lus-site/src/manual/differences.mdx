---
order: 2
title: Differences from Lua
---

## Protected execution

Lua implements error handling at the function level. `pcall` and `xpcall` are invoked by the programmer to execute a function in protected mode, which often requires the use of anonymous functions even when a single expression is evaluated.

Lus deprecates function-level protected execution and replaces it with the `catch` expression, which evaluates any expression in protected mode and returns a boolean success flag alongside the result of the expression or the error message. This allows for more granular error handling that does not require the use of anonymous functions or dependence on the global library.

```lua
local success, result = catch 1 + "a"

if success then
  print(result)
else
  print(result)
end
```

## Optional chaining

Lua does not have a built-in optional chaining operator. This means that when accessing a value that may be nil, the programmer must verify the value is not nil before accessing it, which often requires nested conditional expressions.

Lus introduces the ? operator, which enables safe navigation through potentially nil values. If the value before ? is falsy (nil or false), subsequent suffix operations (field access, indexing, method calls, function calls) short-circuit and return the falsy value instead of raising an error. This allows for more concise and readable code when navigating values that may be nil.

```lua
local t = { a = {} }
local x = t? -- x will be equal to t.
local y = t?.a -- y will be equal to t.a.
local z = t?.a?.r?.k?.e?.w -- z will be nil; r? cancels any following expression employing the value.
local k = (w and {} or nil)?.op -- k will be nil, as the expression between parens evals to nil.

local j = 1 + (w and 5 or nil)? -- This will error, as it is essentially the same as "1 + nil".
local i = 1 + (w and 5 or nil)?.a.g.x or 10 -- This will work, as it is essentially the same as "1 + nil or 10".

local e = t?["a"] -- Any operation works; it is '?' that is implemented, not '?.'
```

## Assignment in conditionals

Lua does not allow assignment in the conditional expressions of if/elseif statements. Assigning and testing values in the same expression is not possible, which results in redundant code.

Lus fixes this by simply allowing assignment in the conditional expressions of if/elseif statements. Assignments are scoped to the entire condition including any accompanying else/elseif blocks. If at least one assignment is false or nil, then the condition is false and the next else/elseif is executed.

```lua
local function keepIfSumOverTen(a, b)
    local c = a + b
    return c > 10 and c or nil
end

if s = keepIfSumOverTen(9, 2) then
    print(s .. " is over ten!")
end

-- Also works with multiple values.
if a, b, c = 1, 5, 9 then
    print(a, b, c)
end

-- Will NOT work if ONE of the values are falsy.
if a, b, c = 3, 6, nil then
    print("Unexpected")
elseif d = 9 then
    -- Elseif blocks can also have values!
    -- Values previously declared are available here.
    print("At least one value was missing!", a, b, c, d)
end
```

## Table destructuring

Lua does not have a built-in table destructuring operator. This means that when destructuring a table, the programmer must use separately assign each field to a variable.

Lus introduces the `from` assignment statement, which allows for the destructuring of a table into multiple local or global variables.

```lua
local t = { a = 1, b = 2, c = 3 }
local a, b, c from t
print(a, b, c) -- 1 2 3
```

## Enums

Lua does not have a built-in enum type. Developers typically simulate enums using tables with string keys or sequential integers, but these approaches lack type safety; there's nothing preventing comparison between unrelated "enum" values or accidental use of invalid values.

Lus introduces first-class enums with the `enum ... end` expression. Enum values are symbols: they are only equal to other values from the same enum with the same name. This provides type safety while still allowing ordering comparisons by position. Use `tonumber()` to get the 1-based index, and index any enum value by name or number to access other members of the same enum.

```lua
local color = enum red, green, blue end
local status = enum ok, error end

-- Enums are symbols, not numbers
assert(color.red ~= status.ok)  -- Different enums, never equal
assert(color == color.red)      -- Enum equals its first value

-- Ordering by position
assert(color.red < color.green)

-- Access by name or index
assert(color.red.blue == color.blue)
assert(color[2] == color.green)

-- Get numeric index
assert(tonumber(color.blue) == 3)
```
