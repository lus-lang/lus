---
order: 110
title: Acquis 10 - Network
acquis: true
draft: true
---

The `network` library provides TCP, UDP, and HTTP/HTTPS networking with native SSL support. It integrates with the event loop for non-blocking I/O in detached coroutines.

## HTTP requests

Use `network.fetch` for HTTP and HTTPS requests:

```lua
local status, body, headers = network.fetch("https://httpbin.org/get")
print(status)  -- 200
print(#body)   -- response size
print(headers["content-type"])  -- "application/json"
```

### POST requests

Pass method, headers, and body as additional arguments:

```lua
local status, body = network.fetch(
  "https://httpbin.org/post",
  "POST",
  {["Content-Type"] = "application/json"},
  '{"name": "Lus"}'
)
```

### Error handling

Network errors raise Lua errors:

```lua
local ok, err = catch network.fetch("https://invalid.host.example")
if not ok then
  print("Request failed:", err)
end
```

## TCP connections

### Client connections

Connect to a TCP server and exchange data:

```lua
local sock = network.tcp.connect("example.com", 80)
sock:settimeout(5)  -- 5 second timeout

sock:send("GET / HTTP/1.0\r\nHost: example.com\r\n\r\n")
local response = sock:receive("*a")  -- receive until EOF
sock:close()
```

### Receive patterns

The `receive` method supports several patterns:

```lua
-- Receive exactly N bytes
local data = sock:receive(1024)

-- Receive a line (strips trailing newline)
local line = sock:receive("*l")

-- Receive all data until EOF
local all = sock:receive("*a")
```

### TCP servers

Create a listening server:

```lua
local server = network.tcp.bind("127.0.0.1", 8080)
server:settimeout(10)

local client = server:accept()
client:settimeout(5)

local request = client:receive("*l")
client:send("HTTP/1.0 200 OK\r\n\r\nHello!\n")
client:close()

server:close()
```

## UDP sockets

Create, send, and receive datagrams:

```lua
-- Sender
local sender = network.udp.open()
sender:sendto("Hello UDP", "127.0.0.1", 9000)
sender:close()

-- Receiver (bound to port)
local receiver = network.udp.open(9000, "127.0.0.1")
local data, addr, port = receiver:receive()
print(data, addr, port)  -- "Hello UDP", "127.0.0.1", sender_port
receiver:close()
```

## Async I/O with event loop

Network operations become non-blocking in detached coroutines. Use `coroutine.poll` to process the event loop and `coroutine.pending` to check for waiting coroutines:

```lua
local status1, status2
local co = coroutine.create(function()
  -- These yield when they would block, resume automatically when ready
  local body1, body2
  status1, body1 = network.fetch("https://api.example.com/data1")
  status2, body2 = network.fetch("https://api.example.com/data2")
end)

coroutine.detach(co)  -- starts execution immediately

-- Poll until complete
while coroutine.pending() > 0 do
  coroutine.poll(5)
end

print(status1, status2)  -- results are available
```

### Parallel requests

Multiple detached coroutines run concurrently:

```lua
local results = {}

for i, endpoint in ipairs({"users", "posts", "comments"}) do
  local co = coroutine.create(function()
    local status, body = network.fetch("https://api.example.com/" .. endpoint)
    results[i] = {status = status, body = body}
  end)
  coroutine.detach(co)
end

-- All three requests run in parallel
while coroutine.pending() > 0 do
  coroutine.poll(5)
end

-- All results ready
for i, r in ipairs(results) do
  print(i, r.status)
end
```

### Async TCP example

```lua
local response_size
local co = coroutine.create(function()
  local sock = network.tcp.connect("example.com", 80)
  sock:settimeout(5)
  
  sock:send("GET / HTTP/1.0\r\nHost: example.com\r\n\r\n")
  local response = sock:receive("*a")  -- yields, doesn't block
  sock:close()
  
  response_size = #response
end)

coroutine.detach(co)
while coroutine.pending() > 0 do
  coroutine.poll(5)
end

print("Received", response_size, "bytes")
```

### Error handling in async code

Errors in detached coroutines are thrown by `poll()`. Use `catch` to handle them:

```lua
local co = coroutine.create(function()
  network.fetch("https://invalid.host.example")
end)

coroutine.detach(co)

while coroutine.pending() > 0 do
  local ok, err = catch coroutine.poll(5)
  if not ok then
    print("Request failed:", err)
  end
end
```

## Socket methods

### TCP client socket

| Method | Description |
|--------|-------------|
| `send(data)` | Send data, returns bytes sent |
| `receive([pattern])` | Receive data (default: `"*l"`) |
| `settimeout(seconds)` | Set operation timeout |
| `close()` | Close the connection |

### TCP server

| Method | Description |
|--------|-------------|
| `accept()` | Accept a client connection |
| `settimeout(seconds)` | Set accept timeout |
| `close()` | Stop listening |

### UDP socket

| Method | Description |
|--------|-------------|
| `sendto(data, addr, port)` | Send datagram |
| `receive([size])` | Receive datagram (default: 8192) |
| `setsockname(addr, port)` | Bind to address and port |
| `close()` | Close the socket |

---

## Motivation

Lus provides native networking without external dependencies. The library handles platform differences and integrates with the event loop for modern async patterns.

### Single-call HTTP

Compare to using raw sockets:

```lua
-- Without network.fetch: 20+ lines of socket, TLS, HTTP parsing
-- With network.fetch:
local status, body = network.fetch("https://api.example.com/data")
```

### Transparent async

I/O automatically becomes non-blocking in detached coroutines:

```lua
-- Blocking (in regular code)
local status = network.fetch(url)

-- Non-blocking (in detached coroutine)
local co = coroutine.create(function()
  result = network.fetch(url)  -- yields during I/O
end)
coroutine.detach(co)
while coroutine.pending() > 0 do
  -- Can do other work here
  coroutine.poll(0.1)
end
```

### Cross-platform consistency

The library handles platform-specific socket APIs (Winsock vs POSIX) and TLS configuration transparently.
