---
order: 109
title: Acquis 9 - Event Loop
acquis: true
draft: true
---

The event loop enables detached coroutines to perform non-blocking I/O and timed sleeps. Coroutines marked with `coroutine.detach` participate in event-driven execution, automatically yielding when I/O would block and resuming when ready.

## Core API

### coroutine.detach(co)

Starts a coroutine for event-driven execution. Returns a status enum value:

```lua
local co = coroutine.create(function()
  coroutine.sleep(0.1)  -- yields for 100ms
  print("done!")
end)

local status = coroutine.detach(co)
-- status is coroutine.status_e.pending (waiting on sleep)
```

The return value is one of:
- `coroutine.status_e.pending` — coroutine hit async I/O or sleep, now waiting in event loop
- `coroutine.status_e.completed` — coroutine finished synchronously
- `coroutine.status_e.yielded` — coroutine paused via explicit `coroutine.yield()`
- `coroutine.status_e.error` — coroutine terminated with an error

### coroutine.poll(timeout)

Processes the event loop, checking for ready I/O and resuming waiting coroutines:

```lua
-- Poll with 5 second timeout
coroutine.poll(5)

-- Non-blocking poll (check once and return)
coroutine.poll(0)

-- Block indefinitely until something is ready
coroutine.poll(-1)
```

**Important**: Errors that occur in detached coroutines are thrown by `poll()`. Wrap with `catch` to handle them:

```lua
local ok, err = catch coroutine.poll(5)
if not ok then
  print("A detached coroutine failed:", err)
end
```

### coroutine.pending()

Returns the number of detached coroutines currently waiting on I/O or sleep:

```lua
-- Wait for all pending coroutines to complete
while coroutine.pending() > 0 do
  coroutine.poll(5)
end
```

## Basic usage

```lua
-- Create a coroutine that sleeps
local co = coroutine.create(function()
  print("starting")
  coroutine.sleep(0.1)  -- 100ms
  print("done")
end)

-- Detach starts it immediately
local status = coroutine.detach(co)
print(status == coroutine.status_e.pending)  -- true

-- Poll until completion
while coroutine.pending() > 0 do
  coroutine.poll(5)
end
```

## Sleeping

`coroutine.sleep(seconds)` yields the coroutine for the specified duration:

```lua
coroutine.sleep(1.5)    -- sleep 1.5 seconds
coroutine.sleep(0.001)  -- sleep 1 millisecond
coroutine.sleep(0)      -- yield immediately, resume on next poll
```

Sleep only works in detached coroutines. Calling it in a regular coroutine raises an error:

```lua
local co = coroutine.create(function()
  coroutine.sleep(0.1)  -- error: not detached
end)
local ok, err = coroutine.resume(co)
assert(not ok)
```

## Non-blocking file I/O

File operations (`io.read`, `io.write`) automatically use a thread pool in detached coroutines:

```lua
local content
local co = coroutine.create(function()
  local f = io.open("large_file.txt", "r")
  content = f:read("*a")  -- reads async via thread pool
  f:close()
end)

coroutine.detach(co)

-- Do other work while file is being read...
print("Reading file in background")

while coroutine.pending() > 0 do
  coroutine.poll(1)
end

print("Read", #content, "bytes")
```

### Async operations

The following file operations are async-aware in detached coroutines:
- `file:read("*a")` — read entire file
- `file:read(n)` — read N bytes
- `file:write(data)` — write data (single argument)

### Parallel file operations

Multiple file operations can run concurrently:

```lua
local files = {"data1.txt", "data2.txt", "data3.txt"}
local results = {}

for i, path in ipairs(files) do
  local co = coroutine.create(function()
    local f = io.open(path, "r")
    if f then
      results[i] = f:read("*a")
      f:close()
    end
  end)
  coroutine.detach(co)
end

while coroutine.pending() > 0 do
  coroutine.poll(1)
end

-- All files read in parallel
```

## Non-blocking network I/O

The key advantage of detached coroutines is non-blocking network operations:

```lua
local status, body
local co = coroutine.create(function()
  status, body = network.fetch("https://api.example.com/data")
end)

-- Detach starts the request
coroutine.detach(co)

-- Do other work while waiting...
print("Request started")

-- Poll until the request completes
while coroutine.pending() > 0 do
  coroutine.poll(5)
end

print("Got status:", status)
```

## Parallel operations

Multiple detached coroutines can run concurrently:

```lua
local results = {}

-- Start three parallel requests
for i, url in ipairs({"api1", "api2", "api3"}) do
  local co = coroutine.create(function()
    local status, body = network.fetch("https://example.com/" .. url)
    results[i] = {status = status, body = body}
  end)
  coroutine.detach(co)
end

-- Wait for all to complete
while coroutine.pending() > 0 do
  coroutine.poll(5)
end

-- All results ready
for i, r in ipairs(results) do
  print(i, r.status)
end
```

## Error handling

Errors in detached coroutines are thrown when you call `poll()`:

```lua
local co = coroutine.create(function()
  coroutine.sleep(0.1)
  error("something went wrong")
end)

coroutine.detach(co)

-- Poll and catch any errors
while coroutine.pending() > 0 do
  local ok, err = catch coroutine.poll(5)
  if not ok then
    print("Error:", err)  -- "something went wrong"
  end
end
```

Errors in detached coroutines surface when the event loop processes them, not when the coroutine is started.

## Collecting results

Since detached coroutines use polling rather than returning values, use upvalues or tables to collect results:

```lua
local result
local co = coroutine.create(function()
  local status, body = network.fetch("https://api.example.com/users")
  result = {status = status, body = body}
end)

coroutine.detach(co)
while coroutine.pending() > 0 do
  coroutine.poll(5)
end

print(result.status)  -- 200
```

## Regular yields

Detached coroutines can still use regular `coroutine.yield`. The status from `detach` will be `yielded`:

```lua
local co = coroutine.create(function()
  coroutine.yield("first")
  coroutine.sleep(0.1)
  coroutine.yield("second")
end)

local status = coroutine.detach(co)
assert(status == coroutine.status_e.yielded)

-- Resume to get yielded values
local ok, val = coroutine.resume(co)
print(val)  -- "first"
```

---

## Motivation

Cooperative coroutines are powerful but limited to synchronous execution. Real-world applications need I/O without blocking the entire program.

### Regular coroutines

Coroutines that are **not** detached work exactly as expected. `coroutine.resume` runs the coroutine until it yields or completes, and returns any yielded or returned values:

```lua
local co = coroutine.create(function()
  coroutine.yield("first")
  coroutine.yield("second")
  return "done"
end)

print(coroutine.resume(co))  -- true, "first"
print(coroutine.resume(co))  -- true, "second"
print(coroutine.resume(co))  -- true, "done"
```

This behavior is completely unchanged. Regular coroutines do not interact with the event loop at all.

### Traditional approach

Without an event loop, network operations block:

```lua
-- This blocks the entire program
local status = network.fetch("https://slow-api.example.com")
-- Can't do anything else while waiting
```

### Event-driven execution

With `coroutine.detach` and `poll`, I/O yields control to the event loop:

```lua
local co = coroutine.create(function()
  result = network.fetch("https://slow-api.example.com")
end)
coroutine.detach(co)

-- Your program continues here...
while coroutine.pending() > 0 do
  -- Can do other work between polls
  coroutine.poll(0.1)
end
```

### Opt-in design

The event loop is entirely opt-in:

- Regular coroutines work exactly as before
- Only explicitly detached coroutines participate in event-driven execution  
- `coroutine.sleep` and non-blocking I/O only work in detached coroutines
- All standard coroutine functions (`create`, `resume`, `yield`, `status`) remain unchanged

This design preserves backward compatibility and keeps behavior predictable. Code that doesn't use `detach` will work identically to standard coroutine code.
