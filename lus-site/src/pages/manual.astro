---
import Layout from "../components/Layout.astro"
---

<Layout title="Manual">
  <main>
    <section>
      <h1>Manual</h1>
      <h2>Introduction</h2>
      <p>
        Lus is a small, productive programming language derived from Lua. It's
        not meant to follow the latest trends in programming language theory,
        but to iterate on the minimalism and ease of use of Lua so that it can
        better solve real-world problems.
      </p>
      <p>
        It is a <i>superset</i> of Lua, meaning that most Lua code is also valid
        Lus code. Seasoned Lua programmers should be able to pick up Lus easily and
        make use of its benefits right away. However, unlike most other language
        supersets, Lus has its own runtime and standard library, so it is a complete
        language in its own right.
      </p>
      <p>
        Lus is a personal project of <a href="https://github.com/loukamb"
          >Louka MÃ©nard Blondin</a
        > and is maintained on a best-effort basis.
      </p>
      <h2>Goals</h2>
      <p>
        These are the design goals of Lus that guide the language's development.
      </p>
      <ul>
        <li>
          <b>Boring is good.</b> The language should not implement every new trend
          in programming language theory. It should be small, predictable, and easy
          to work with while remaining extensible.
        </li>
        <li>
          <b>Solve real-world problems.</b> The language must be oriented towards
          productivity and not just theoretical purity. This implies strong Socratic
          questioning of every proposed modification to determine their usefulness
          and value.
        </li>
        <li>
          <b>Sovereignty.</b> The language should be reasonably usable on its own
          without dependence on third-party runtimes or libraries. The standard library
          must be greatly extended from Lua's core library to provide a complete
          language.
        </li>
        <li>
          <b>Minimalism.</b> Lus should retain Lua's ease of <i>adoption</i>,
          with concise and readable syntax. Syntactic additions should fit
          naturally into the language, and existing syntax should not be changed
          unless absolutely necessary.
        </li>
        <li>
          <b>Strong release enginering.</b> The language should have stable, well-tested
          releases and not be in a constant state of flux. This means not being afraid
          of waiting long periods of time between releases.
        </li>
      </ul>
      <p>The following are <b>non-goals</b> of Lus.</p>
      <ul>
        <li>
          <b>Strong typing.</b> The language should remain appreciative of Lua's
          strict adherence to dynamic typing. Virtually all other derivatives of
          Lua add strong typing features, which are distracting and detrimental to
          the language's productivity.
        </li>
        <li>
          <b>Modules.</b> The language should not introduce modules, which are an
          anti-pattern imported from JavaScript. Instead, it should rely on the existing
          require-based loader system to load code. This means no
          <code>import</code>/<code>export</code> functionality.
        </li>
      </ul>
      <h2>Key Grammar Differences</h2>
      <h3>Protected Execution</h3>
      <p>
        Lua implements error handling at the function level. <code>pcall</code> and
        <code>xpcall</code> are invoked by the programmer to execute a function in
        protected mode, which often requires the use of anonymous functions even
        when a single expression is evaluated.
      </p>
      <p>
        Lus deprecates function-level protected execution and replaces it with
        the <code>catch</code> expression, which evaluates any expression in protected
        mode and returns a boolean success flag alongside the result of the expression
        or the error message. This allows for more granular error handling that does
        not require the use of anonymous functions or dependence on the global library.
      </p>
      <pre>
        <code>
local success, result = catch 1 + "a"
if success then
    print(result)
else
    print(result)
end
        </code>
      </pre>
      <h3>Optional Chaining</h3>
      <p>
        Lua does not have a built-in optional chaining operator. This means that
        when accessing a value that may be nil, the programmer must verify the
        value is not nil before accessing it, which often requires nested
        conditional expressions.
      </p>
      <p>
        Lus introduces the <code>?</code> operator, which enables safe navigation
        through potentially nil values. If the value before <code>?</code> is falsy
        (nil or false), subsequent suffix operations (field access, indexing, method
        calls, function calls) short-circuit and return the falsy value instead of
        raising an error. This allows for more concise and readable code when navigating
        values that may be nil.
      </p>
      <pre>
        <code>
{`local t = { a = {} }
local x = t? -- x will be equal to t.
local y = t?.a -- y will be equal to t.a.
local z = t?.a?.r?.k?.e?.w -- z will be nil; r? cancels any following expression employing the value.
local k = (w and {} or nil)?.op -- k will be nil, as the expression between parens evals to nil.

local j = 1 + (w and 5 or nil)? -- This will error, as it is essentially the same as "1 + nil".
local i = 1 + (w and 5 or nil)?.a.g.x or 10 -- This will work, as it is essentially the same as "1 + nil or 10".

local e = t?["a"] -- Any operation works; it is '?' that is implemented, not '?.'`}
        </code>
      </pre>
      <h3>Assignment in Conditionals</h3>
      <p>
        Lua does not allow assignment in the conditional expressions of
        if/elseif statements. Assigning <i>and</i> testing values in the same expression
        is not possible, which results in redundant code.
      </p>
      <p>
        Lus fixes this by simply allowing assignment in the conditional
        expressions of if/elseif statements. Assignments are scoped to the
        entire condition including any accompanying else/elseif blocks. If at
        least one assignment is false or nil, then the condition is false and
        the next else/elseif is executed.
      </p>
      <pre>
        <code>
local function keepIfSumOverTen(a, b)
    local c = a + b
    return c > 10 and c or nil
end

if s = keepIfSumOverTen(9, 2) then
    print(s .. " is over ten!")
end

-- Also works with multiple values.
if a, b, c = 1, 5, 9 then
    print(a, b, c)
end

-- Will NOT work if ONE of the values are falsy.
if a, b, c = 3, 6, nil then
    print("Unexpected")
elseif d = 9 then
    -- Elseif blocks can also have values!
    -- Values previously declared are available here.
    print("At least one value was missing!", a, b, c, d)
end
        </code>
      </pre>
      <h3>Table destructuring</h3>
      <p>
        Lua does not have a built-in table destructuring operator. This means
        that when destructuring a table, the programmer must use separately
        assign each field to a variable.
      </p>
      <p>
        Lus introduces the <code>from</code> assignment statement, which allows for
        the destructuring of a table into multiple local or global variables.
      </p>
      <pre>
        <code>
{`local t = { a = 1, b = 2, c = 3 }
local c, b, a from t
print(a, b, c)

-- Very useful when importing modules.
local useState, useEffect from require("react")
`}
        </code>
      </pre>
      <h2>Library Differences</h2>
      To do...
    </section>
  </main>
</Layout>
