--[[
  Comprehensive Error Handling Tests for Lus
  Tests: error(), assert(), and catch expression
  
  Note: pcall and xpcall have been removed from Lus.
  All protected execution is done via the 'catch' expression.
]]

global print, setmetatable, assert, error, type, _G, coroutine, require, pcall, xpcall, os, pledge, collectgarbage

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("errors")

tests:it("error() with string message", function()
    local ok, err = catch error("test error")
    assert(not ok)
    assert(err:find("test error"), "Error message should contain 'test error'")
end)

tests:it("error() with number message", function()
    local ok, err = catch error(42)
    assert(not ok)
    assert(type(err) == "string", "Error should be converted to string")
end)

tests:it("error() with table message", function()
    local t = {code = 500, msg = "Internal error"}
    local ok, err = catch error(t)
    assert(not ok)
    assert(type(err) == "string", "Error should be converted to string")
end)

tests:it("error() with level 0", function()
    local ok, err = catch error("custom error", 0)
    assert(not ok)
    assert(err:find("custom error"), "Error message should contain the original text")
end)

tests:it("assert() with true", function()
    local result = assert(true)
    assert(result == true)
end)

tests:it("assert() with truthy value", function()
    local result = assert(42)
    assert(result == 42)
end)

tests:it("assert() with string", function()
    local result = assert("hello")
    assert(result == "hello")
end)

tests:it("assert() with false raises error", function()
    local ok, err = catch assert(false)
    assert(not ok)
    assert(err:find("assertion failed"))
end)

tests:it("assert() with nil raises error", function()
    local ok = catch assert(nil)
    assert(not ok)
end)

tests:it("assert() with custom message", function()
    local ok, err = catch assert(false, "custom failure message")
    assert(not ok)
    assert(err:find("custom failure message"))
end)

tests:it("assert() preserves multiple return values", function()
    local a, b, c = assert(1, 2, 3)
    assert(a == 1 and b == 2 and c == 3)
end)

tests:it("catch with successful expression", function()
    local ok, result = catch 1 + 2
    assert(ok == true)
    assert(result == 3)
end)

tests:it("catch with failing expression (nil arithmetic)", function()
    local ok, err = catch 1 + nil
    assert(ok == false)
    assert(type(err) == "string")
    assert(err:find("nil"))
end)

tests:it("catch with successful function call", function()
    local function add(a, b) return a + b end
    local ok, result = catch add(10, 20)
    assert(ok == true)
    assert(result == 30)
end)

tests:it("catch with failing function call", function()
    local function fail() error("function failed") end
    local ok, err = catch fail()
    assert(ok == false)
    assert(err:find("function failed"))
end)

tests:it("catch with error() directly", function()
    local ok, err = catch error("direct error")
    assert(ok == false)
    assert(err:find("direct error"))
end)

tests:it("catch with nested function error", function()
    local function inner() error("from inner") end
    local function outer() inner() end
    local ok, err = catch outer()
    assert(ok == false)
    assert(err:find("from inner"))
end)

tests:it("catch with multi-return function", function()
    local function multi() return 1, 2, 3 end
    local ok, a, b, c = catch multi()
    assert(ok == true)
    assert(a == 1 and b == 2 and c == 3)
end)

tests:it("catch with fewer returns than expected (nil-fill)", function()
    local function two() return 10, 20 end
    local ok, a, b, c, d = catch two()
    assert(ok == true)
    assert(a == 10 and b == 20)
    assert(c == nil and d == nil)
end)

tests:it("catch error with nil-fill for extra vars", function()
    local function fails() error("oops") end
    local x, y, z = catch fails()
    assert(x == false)
    assert(type(y) == "string")
    assert(z == nil, "Extra variables should be nil on error")
end)

tests:it("catch returned from function preserves all values", function()
    local function multi() return "a", "b", "c" end
    local function wrapper()
        return catch multi()
    end
    local ok, v1, v2, v3 = wrapper()
    assert(ok == true)
    assert(v1 == "a" and v2 == "b" and v3 == "c")
end)

tests:it("catch in table constructor", function()
    local function multi() return 1, 2, 3 end
    local t = { catch multi() }
    assert(t[1] == true)
    assert(t[2] == 1 and t[3] == 2 and t[4] == 3)
end)

tests:it("catch with vararg function", function()
    local function varfn(...) return ... end
    local ok, a, b, c = catch varfn(100, 200, 300)
    assert(ok == true)
    assert(a == 100 and b == 200 and c == 300)
end)

tests:it("catch in local assignment", function()
    local status, value = catch (100 / 2)
    assert(status == true)
    assert(value == 50)
end)

tests:it("catch in global assignment", function()
    _G.test_status, _G.test_value = catch error("global test")
    assert(_G.test_status == false)
    assert(type(_G.test_value) == "string")
    _G.test_status, _G.test_value = nil, nil
end)

tests:it("catch as function argument", function()
    local function receive(a, b)
        return a, b
    end
    local x, y = receive(catch (42))
    assert(x == true)
    assert(y == 42)
end)

tests:it("catch in print (success)", function()
    local old_print = print
    local captured = {}
    print = function(...) captured = {...} end
    print(catch (999))
    print = old_print
    assert(captured[1] == true)
    assert(captured[2] == 999)
end)

tests:it("catch with method call success", function()
    local obj = {
        value = 21,
        double = function(self) return self.value * 2 end
    }
    local ok, result = catch obj:double()
    assert(ok == true and result == 42)
end)

tests:it("catch with method call error", function()
    local obj = {
        fail = function(self) error("method error") end
    }
    local ok, err = catch obj:fail()
    assert(ok == false)
    assert(err:find("method error"))
end)

tests:it("catch in loop", function()
    local errors = 0
    for i = 1, 5 do
        local ok = catch error("loop " .. i)
        if not ok then errors = errors + 1 end
    end
    assert(errors == 5)
end)

tests:it("catch with nil indexing", function()
    local t = nil
    local ok, err = catch t.field
    assert(ok == false)
    assert(err:find("nil"))
end)

tests:it("catch does not affect outer scope on error", function()
    local x = 100
    local ok = catch error("test")
    assert(ok == false)
    assert(x == 100, "Local variable should be unchanged")
end)

tests:it("pcall is not defined", function()
    assert(pcall == nil, "pcall should not exist")
end)

tests:it("xpcall is not defined", function()
    assert(xpcall == nil, "xpcall should not exist")
end)

tests:it("catch with very deep call stack", function()
    local function recurse(n)
        if n <= 0 then return n end
        return recurse(n - 1)
    end
    local ok, result = catch recurse(100)
    assert(ok == true)
    assert(result == 0)
end)

tests:it("catch with error in deeply nested call", function()
    local function recurse(n)
        if n <= 0 then error("bottom") end
        return recurse(n - 1)
    end
    local ok, err = catch recurse(50)
    assert(ok == false)
    assert(err:find("bottom"))
end)

tests:it("catch multiple times in sequence", function()
    for i = 1, 100 do
        local ok = catch error("seq " .. i)
        assert(ok == false)
    end
end)

tests:it("catch handles table errors", function()
    local err_obj = {code = 404, message = "not found"}
    local function throw_obj() error(err_obj) end
    local ok, err = catch throw_obj()
    assert(ok == false)
    assert(type(err) == "string")
end)

tests:it("catch with metamethod error (__add)", function()
    local mt = {
        __add = function() error("metamethod error") end
    }
    local a = setmetatable({}, mt)
    local ok, err = catch (a + 1)
    assert(ok == false)
    assert(err:find("metamethod error"))
end)

tests:it("catch with metamethod error (__index)", function()
    local mt = {
        __index = function() error("index error") end
    }
    local a = setmetatable({}, mt)
    local ok, err = catch a.foo
    assert(ok == false)
    assert(err:find("index error"))
end)

tests:it("catch with metamethod error (__call)", function()
    local mt = {
        __call = function() error("call error") end
    }
    local a = setmetatable({}, mt)
    local ok, err = catch a()
    assert(ok == false)
    assert(err:find("call error"))
end)

tests:it("catch with coroutine.yield in main thread", function()
    local ok, err = catch coroutine.yield()
    assert(ok == false)
end)

tests:it("catch with assert failure", function()
    local ok, err = catch assert(false, "assert failed")
    assert(ok == false)
    assert(err:find("assert failed"))
end)

-- ============================================
-- Additional Negative/Edge Case Tests
-- ============================================

tests:it("error() with level beyond stack depth", function()
    -- Level larger than stack depth should work but adjust line info
    local ok, err = catch error("high level error", 100)
    assert(not ok)
    assert(err:find("high level error"))
end)

tests:it("error() with negative level", function()
    local ok, err = catch error("negative level", -1)
    assert(not ok)
    assert(err:find("negative level"))
end)

tests:it("nested catch expressions", function()
    -- catch inside catch
    local outer_ok, outer_result = catch (function()
        local inner_ok, inner_err = catch error("inner error")
        assert(not inner_ok)
        assert(inner_err:find("inner error"))
        return "outer success"
    end)()
    assert(outer_ok)
    assert(outer_result == "outer success")
end)

tests:it("catch propagates through multiple levels", function()
    local function level3() error("deep error") end
    local function level2() level3() end
    local function level1() level2() end
    
    local ok, err = catch level1()
    assert(not ok)
    assert(err:find("deep error"))
end)

tests:it("error in __gc finalizer becomes warning", function()
    -- In Lua/Lus, __gc errors are caught by the internal pcall that runs
    -- finalizers and converted to warnings. They do NOT propagate to
    -- enclosing catch blocks.
    local finalized = false
    local mt = {
        __gc = function()
            finalized = true
            error("finalizer error")
        end
    }
    
    -- Run GC - the finalizer error becomes a warning, not a caught error
    local inner_ok, inner_result = catch (function()
        local obj = setmetatable({}, mt)
        obj = nil
        collectgarbage()
        collectgarbage()
        return "success"
    end)()
    
    -- The catch succeeds because __gc errors become warnings
    assert(inner_ok, "__gc errors should become warnings, not propagate to catch")
    assert(inner_result == "success", "function should complete successfully")
    assert(finalized, "finalizer should have run")
end)

tests:it("catch with recursive error", function()
    local count = 0
    local function recurse()
        count = count + 1
        if count > 5 then
            error("recursion limit")
        end
        recurse()
    end
    
    local ok, err = catch recurse()
    assert(not ok)
    assert(err:find("recursion limit"))
    assert(count > 5)
end)

tests:it("catch with nil error message", function()
    local ok, err = catch error(nil)
    assert(not ok)
    -- error(nil) should produce some error message
    assert(err ~= nil)
end)

tests:it("catch with boolean error", function()
    local ok, err = catch error(true)
    assert(not ok)
    -- Error messages may remain as booleans or be converted to strings
    assert(err == true or type(err) == "string", "error should be boolean or string")
end)

tests:it("catch in coroutine", function()
    local co = coroutine.create(function()
        local ok, err = catch error("coroutine error")
        assert(not ok)
        assert(err:find("coroutine error"))
        return "coro done"
    end)
    
    local success, result = coroutine.resume(co)
    assert(success)
    assert(result == "coro done")
end)

tests:it("error from tostring in error message", function()
    local mt = {
        __tostring = function() error("tostring error") end
    }
    local obj = setmetatable({}, mt)
    
    -- When error() is called with an object whose __tostring throws,
    -- the tostring error propagates as the error message
    local ok, err = catch error(obj)
    assert(not ok, "error should be caught")
    assert(type(err) == "string", "error should be a string")
    assert(err:find("tostring error"), "error should contain tostring error message")
end)

tests:it("catch catches stack overflow", function()
    -- NOTE: Must use non-tail-recursive function to actually trigger stack overflow.
    -- A tail-recursive function like `return infinite()` gets optimized to reuse
    -- the same stack frame, so it runs forever without overflowing.
    local function non_tail_infinite(n)
        n = n + 1
        non_tail_infinite(n)
        return n  -- prevents tail call optimization
    end
    local ok, err = catch non_tail_infinite(0)
    assert(not ok, "should have caught stack overflow")
    assert(err:find("stack overflow"), "error should mention stack overflow")
end)

tests:it("catch with multiple sequential errors", function()
    -- Multiple errors in sequence should all be caught properly
    for i = 1, 10 do
        local ok, err = catch error("error " .. i)
        assert(not ok)
        assert(err:find("error " .. i))
    end
end)

tests:it("error during table construction", function()
    local function throwing() error("construction error") end
    local ok, err = catch (function()
        local t = { a = 1, b = throwing() }
    end)()
    assert(not ok)
    assert(err:find("construction error"))
end)

tests:finish()