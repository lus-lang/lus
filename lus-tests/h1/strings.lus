global print, require, string, math, assert, package, pairs, ipairs, type, error, _G, table, load, tostring, tonumber, select, rawset, os, coroutine, pledge

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("strings")

local string = string
local table = table
local math = math

local function checkerror (msg, f, ...)
  local args = {...}
  local s, err = catch (function() return f(table.unpack(args)) end)()
  assert(not s and string.find(err, msg))
end

tests:it("basic string length and concatenation", function()
    assert("alo" < "alo1")
    assert("" < "a")
    assert("alo" > "al")
    assert("alo" ~= "alo1")
    assert("alo" ~= nil)
    assert("alo" ~= 1)
    
    assert("alo" .. "123" == "alo123")
    assert("alo" .. 123 == "alo123")
    assert(123 .. "alo" == "123alo")
    assert(123 .. 456 == "123456")
    
    assert(string.len("") == 0)
    assert(string.len("abc") == 3)
    assert(string.len("123") == 3)
    
    assert(string.rep('a', 5) == "aaaaa")
    assert(string.rep('', 10) == "")
    assert(string.rep('a', 0) == "")
    assert(string.rep('a', -1) == "")
end)

tests:it("string.sub", function()
    assert(string.sub("123456789", 2, 4) == "234")
    assert(string.sub("123456789", 7) == "789")
    assert(string.sub("123456789", 7, 6) == "")
    assert(string.sub("123456789", 7, 7) == "7")
    assert(string.sub("123456789", 0, 0) == "")
    assert(string.sub("123456789", -10, 10) == "123456789")
    assert(string.sub("123456789", 1, 9) == "123456789")
    assert(string.sub("123456789", -10, -20) == "")
    assert(string.sub("123456789", -1) == "9")
    assert(string.sub("123456789", -4) == "6789")
    assert(string.sub("123456789", -6, -4) == "456")
end)

tests:it("string.find", function()
    assert(string.find("123456789", "345") == 3)
    local a, b = string.find("123456789", "345")
    assert(a == 3 and b == 5)
    
    assert(string.find("123456789", "346") == nil)
    assert(string.find("123456789", ".45", 1, true) == nil) -- plain search
    assert(string.find("123456789", "888", 1, true) == nil)
    assert(string.find("123456789", "1", 1, true) == 1)
    
    assert(string.find("123456789", "", 1) == 1)
    assert(string.find("123456789", "", 10) == 10)
end)

tests:it("string.match", function()
    assert(string.match("123456789", "345") == "345")
    assert(string.match("123456789", "3(%d)5") == "4")
    assert(string.match("123456789", "888") == nil)
end)

tests:it("string.gsub", function()
    assert(string.gsub("hello world", "(%w+)", "%1 %1") == "hello hello world world")
    assert(string.gsub("hello world", "%w+", "%0 %0", 1) == "hello hello world")
    assert(string.gsub("hello world from lua", "%a+", function(w) return string.sub(w, 1, 1) end) == "h w f l")
end)

tests:it("string.reverse", function()
    assert(string.reverse("abc") == "cba")
    assert(string.reverse("") == "")
    assert(string.reverse("ab") == "ba")
end)

tests:it("string.unicode", function()
    -- string.char / string.byte
    assert(string.byte("a") == 97)
    assert(string.char(97) == "a")
    assert(string.byte("abc", 2) == 98)
    assert(string.byte("abc", 2, 3) == 98) -- returns multiple?

    local a, b = string.byte("abc", 1, 2)
    assert(a == 97 and b == 98)
end)

tests:it("string.format", function()
    assert(string.format("x%u", 10) == "x10")
    assert(string.format("%d", 123) == "123")
    assert(string.format("%s", "test") == "test")
    assert(string.format("%%%d", 10) == "%10")
    
    -- basic float formats
    assert(string.format("%0.2f", 1.234) == "1.23")
    
    checkerror("invalid conversion", string.format, "%k", 10)
    checkerror("invalid conversion", string.format, "%", 10)
end)

tests:it("table.concat", function()
    local a = {"a", "b", "c"}
    assert(table.concat(a) == "abc")
    assert(table.concat(a, ",") == "a,b,c")
    assert(table.concat(a, ",", 2) == "b,c")
    assert(table.concat(a, ",", 2, 2) == "b")
    assert(table.concat(a, ",", 3, 2) == "")
    
    checkerror("table expected", table.concat, 3)
end)

tests:it("gmatch across coroutines (bug 5.3.2)", function()
  local f = string.gmatch("1 2 3 4 5", "%d+")
  assert(f() == "1")
  local co = coroutine.wrap(f)
  assert(co() == "2")
end)

tests:it("string.pack basic integers", function()
  -- basic integer packing
  local packed = string.pack("i4", 123456)
  assert(#packed == 4)
  local val = string.unpack("i4", packed)
  assert(val == 123456)
  
  -- unsigned integers
  packed = string.pack("I4", 0xFFFFFFFF)
  val = string.unpack("I4", packed)
  assert(val == 0xFFFFFFFF)
  
  -- negative integers
  packed = string.pack("i4", -12345)
  val = string.unpack("i4", packed)
  assert(val == -12345)
  
  -- byte (signed and unsigned)
  packed = string.pack("b", -1)
  val = string.unpack("b", packed)
  assert(val == -1)
  
  packed = string.pack("B", 255)
  val = string.unpack("B", packed)
  assert(val == 255)
end)

tests:it("string.pack shorts and longs", function()
  -- short
  local packed = string.pack("h", 12345)
  assert(#packed == 2)
  local val = string.unpack("h", packed)
  assert(val == 12345)
  
  -- unsigned short
  packed = string.pack("H", 65535)
  val = string.unpack("H", packed)
  assert(val == 65535)
  
  -- lua_Integer (j/J)
  packed = string.pack("j", 123456789)
  val = string.unpack("j", packed)
  assert(val == 123456789)
end)

tests:it("string.pack floats", function()
  -- float
  local packed = string.pack("f", 3.14)
  assert(#packed == 4)
  local val = string.unpack("f", packed)
  assert(math.abs(val - 3.14) < 0.001)
  
  -- double
  packed = string.pack("d", 3.14159265358979)
  assert(#packed == 8)
  val = string.unpack("d", packed)
  assert(math.abs(val - 3.14159265358979) < 0.0000001)
  
  -- lua_Number (n)
  packed = string.pack("n", 2.718281828)
  val = string.unpack("n", packed)
  assert(math.abs(val - 2.718281828) < 0.0000001)
end)

tests:it("string.pack endianness", function()
  -- little endian
  local packed = string.pack("<i4", 0x01020304)
  assert(string.byte(packed, 1) == 0x04) -- least significant first
  
  -- big endian
  packed = string.pack(">i4", 0x01020304)
  assert(string.byte(packed, 1) == 0x01) -- most significant first
  
  -- verify unpack handles endianness
  local le = string.pack("<i4", 1000)
  local be = string.pack(">i4", 1000)
  assert(string.unpack("<i4", le) == 1000)
  assert(string.unpack(">i4", be) == 1000)
end)

tests:it("string.pack fixed strings", function()
  -- fixed-size string
  local packed = string.pack("c5", "hello")
  assert(packed == "hello")
  local val = string.unpack("c5", packed)
  assert(val == "hello")
  
  -- padding on short string
  packed = string.pack("c5", "hi")
  assert(#packed == 5)
  
  -- zero-terminated string
  packed = string.pack("z", "hello")
  assert(#packed == 6) -- includes null terminator
  val = string.unpack("z", packed)
  assert(val == "hello")
end)

tests:it("string.pack multiple values", function()
  local packed = string.pack("i4i4i4", 10, 20, 30)
  assert(#packed == 12)
  
  local a, b, c, nextpos = string.unpack("i4i4i4", packed)
  assert(a == 10)
  assert(b == 20)
  assert(c == 30)
  assert(nextpos == 13) -- next position after data
end)

tests:it("string.pack offset unpack", function()
  local packed = string.pack("xxxi4", 42) -- 3 padding bytes + integer
  assert(#packed == 7)
  
  -- unpack at offset
  local val, nextpos = string.unpack("i4", packed, 4)
  assert(val == 42)
  assert(nextpos == 8)
end)

tests:it("string.packsize", function()
  assert(string.packsize("i4") == 4)
  assert(string.packsize("i4i4") == 8)
  assert(string.packsize("bBhHlLjJ") > 0)
  assert(string.packsize("fd") == 12)
  assert(string.packsize("c10") == 10)
  assert(string.packsize("xxx") == 3)
end)

tests:finish()
