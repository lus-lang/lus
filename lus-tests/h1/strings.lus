global print, require, string, math, assert, package, pairs, ipairs, type, error, _G, table, load, tostring, tonumber, select, rawset, os, coroutine, pledge

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("strings")

local string = string
local table = table
local math = math

local function checkerror (msg, f, ...)
  local args = {...}
  local s, err = catch (function() return f(table.unpack(args)) end)()
  assert(not s and string.find(err, msg))
end

tests:it("basic string length and concatenation", function()
    assert("alo" < "alo1")
    assert("" < "a")
    assert("alo" > "al")
    assert("alo" ~= "alo1")
    assert("alo" ~= nil)
    assert("alo" ~= 1)
    
    assert("alo" .. "123" == "alo123")
    assert("alo" .. 123 == "alo123")
    assert(123 .. "alo" == "123alo")
    assert(123 .. 456 == "123456")
    
    assert(string.len("") == 0)
    assert(string.len("abc") == 3)
    assert(string.len("123") == 3)
    
    assert(string.rep('a', 5) == "aaaaa")
    assert(string.rep('', 10) == "")
    assert(string.rep('a', 0) == "")
    assert(string.rep('a', -1) == "")
end)

tests:it("string.sub", function()
    assert(string.sub("123456789", 2, 4) == "234")
    assert(string.sub("123456789", 7) == "789")
    assert(string.sub("123456789", 7, 6) == "")
    assert(string.sub("123456789", 7, 7) == "7")
    assert(string.sub("123456789", 0, 0) == "")
    assert(string.sub("123456789", -10, 10) == "123456789")
    assert(string.sub("123456789", 1, 9) == "123456789")
    assert(string.sub("123456789", -10, -20) == "")
    assert(string.sub("123456789", -1) == "9")
    assert(string.sub("123456789", -4) == "6789")
    assert(string.sub("123456789", -6, -4) == "456")
end)

tests:it("string.find", function()
    assert(string.find("123456789", "345") == 3)
    local a, b = string.find("123456789", "345")
    assert(a == 3 and b == 5)
    
    assert(string.find("123456789", "346") == nil)
    assert(string.find("123456789", ".45", 1, true) == nil) -- plain search
    assert(string.find("123456789", "888", 1, true) == nil)
    assert(string.find("123456789", "1", 1, true) == 1)
    
    assert(string.find("123456789", "", 1) == 1)
    assert(string.find("123456789", "", 10) == 10)
end)

tests:it("string.match", function()
    assert(string.match("123456789", "345") == "345")
    assert(string.match("123456789", "3(%d)5") == "4")
    assert(string.match("123456789", "888") == nil)
end)

tests:it("string.gsub", function()
    assert(string.gsub("hello world", "(%w+)", "%1 %1") == "hello hello world world")
    assert(string.gsub("hello world", "%w+", "%0 %0", 1) == "hello hello world")
    assert(string.gsub("hello world from lua", "%a+", function(w) return string.sub(w, 1, 1) end) == "h w f l")
end)

tests:it("string.reverse", function()
    assert(string.reverse("abc") == "cba")
    assert(string.reverse("") == "")
    assert(string.reverse("ab") == "ba")
end)

tests:it("string.unicode", function()
    -- string.char / string.byte
    assert(string.byte("a") == 97)
    assert(string.char(97) == "a")
    assert(string.byte("abc", 2) == 98)
    assert(string.byte("abc", 2, 3) == 98) -- returns multiple?

    local a, b = string.byte("abc", 1, 2)
    assert(a == 97 and b == 98)
end)

tests:it("string.format", function()
    assert(string.format("x%u", 10) == "x10")
    assert(string.format("%d", 123) == "123")
    assert(string.format("%s", "test") == "test")
    assert(string.format("%%%d", 10) == "%10")
    
    -- basic float formats
    assert(string.format("%0.2f", 1.234) == "1.23")
    
    checkerror("invalid conversion", string.format, "%k", 10)
    checkerror("invalid conversion", string.format, "%", 10)
end)

tests:it("table.concat", function()
    local a = {"a", "b", "c"}
    assert(table.concat(a) == "abc")
    assert(table.concat(a, ",") == "a,b,c")
    assert(table.concat(a, ",", 2) == "b,c")
    assert(table.concat(a, ",", 2, 2) == "b")
    assert(table.concat(a, ",", 3, 2) == "")
    
    checkerror("table expected", table.concat, 3)
end)

tests:it("gmatch across coroutines (bug 5.3.2)", function()
  local f = string.gmatch("1 2 3 4 5", "%d+")
  assert(f() == "1")
  local co = coroutine.wrap(f)
  assert(co() == "2")
end)

tests:it("string.pack basic integers", function()
  -- basic integer packing
  local packed = string.pack("i4", 123456)
  assert(#packed == 4)
  local val = string.unpack("i4", packed)
  assert(val == 123456)
  
  -- unsigned integers
  packed = string.pack("I4", 0xFFFFFFFF)
  val = string.unpack("I4", packed)
  assert(val == 0xFFFFFFFF)
  
  -- negative integers
  packed = string.pack("i4", -12345)
  val = string.unpack("i4", packed)
  assert(val == -12345)
  
  -- byte (signed and unsigned)
  packed = string.pack("b", -1)
  val = string.unpack("b", packed)
  assert(val == -1)
  
  packed = string.pack("B", 255)
  val = string.unpack("B", packed)
  assert(val == 255)
end)

tests:it("string.pack shorts and longs", function()
  -- short
  local packed = string.pack("h", 12345)
  assert(#packed == 2)
  local val = string.unpack("h", packed)
  assert(val == 12345)
  
  -- unsigned short
  packed = string.pack("H", 65535)
  val = string.unpack("H", packed)
  assert(val == 65535)
  
  -- lua_Integer (j/J)
  packed = string.pack("j", 123456789)
  val = string.unpack("j", packed)
  assert(val == 123456789)
end)

tests:it("string.pack floats", function()
  -- float
  local packed = string.pack("f", 3.14)
  assert(#packed == 4)
  local val = string.unpack("f", packed)
  assert(math.abs(val - 3.14) < 0.001)
  
  -- double
  packed = string.pack("d", 3.14159265358979)
  assert(#packed == 8)
  val = string.unpack("d", packed)
  assert(math.abs(val - 3.14159265358979) < 0.0000001)
  
  -- lua_Number (n)
  packed = string.pack("n", 2.718281828)
  val = string.unpack("n", packed)
  assert(math.abs(val - 2.718281828) < 0.0000001)
end)

tests:it("string.pack endianness", function()
  -- little endian
  local packed = string.pack("<i4", 0x01020304)
  assert(string.byte(packed, 1) == 0x04) -- least significant first
  
  -- big endian
  packed = string.pack(">i4", 0x01020304)
  assert(string.byte(packed, 1) == 0x01) -- most significant first
  
  -- verify unpack handles endianness
  local le = string.pack("<i4", 1000)
  local be = string.pack(">i4", 1000)
  assert(string.unpack("<i4", le) == 1000)
  assert(string.unpack(">i4", be) == 1000)
end)

tests:it("string.pack fixed strings", function()
  -- fixed-size string
  local packed = string.pack("c5", "hello")
  assert(packed == "hello")
  local val = string.unpack("c5", packed)
  assert(val == "hello")
  
  -- padding on short string
  packed = string.pack("c5", "hi")
  assert(#packed == 5)
  
  -- zero-terminated string
  packed = string.pack("z", "hello")
  assert(#packed == 6) -- includes null terminator
  val = string.unpack("z", packed)
  assert(val == "hello")
end)

tests:it("string.pack multiple values", function()
  local packed = string.pack("i4i4i4", 10, 20, 30)
  assert(#packed == 12)
  
  local a, b, c, nextpos = string.unpack("i4i4i4", packed)
  assert(a == 10)
  assert(b == 20)
  assert(c == 30)
  assert(nextpos == 13) -- next position after data
end)

tests:it("string.pack offset unpack", function()
  local packed = string.pack("xxxi4", 42) -- 3 padding bytes + integer
  assert(#packed == 7)
  
  -- unpack at offset
  local val, nextpos = string.unpack("i4", packed, 4)
  assert(val == 42)
  assert(nextpos == 8)
end)

tests:it("string.packsize", function()
  assert(string.packsize("i4") == 4)
  assert(string.packsize("i4i4") == 8)
  assert(string.packsize("bBhHlLjJ") > 0)
  assert(string.packsize("fd") == 12)
  assert(string.packsize("c10") == 10)
  assert(string.packsize("xxx") == 3)
end)

-- ============================================
-- Edge Case Tests
-- ============================================

tests:it("empty string operations", function()
    local s = ""
    assert(string.len(s) == 0)
    assert(string.sub(s, 1, 10) == "")
    assert(string.reverse(s) == "")
    assert(string.upper(s) == "")
    assert(string.lower(s) == "")
    assert(string.rep(s, 100) == "")
    assert(string.find(s, "") == 1)
    assert(string.match(s, ".*") == "")
end)

tests:it("empty string concatenation", function()
    assert("" .. "" == "")
    assert("a" .. "" == "a")
    assert("" .. "b" == "b")
    assert("" .. "" .. "" == "")
end)

tests:it("large string creation with rep", function()
    local s = string.rep("x", 100000)
    assert(#s == 100000)
    assert(string.sub(s, 1, 5) == "xxxxx")
    assert(string.sub(s, -5) == "xxxxx")
end)

tests:it("string.sub edge cases", function()
    local s = "hello"
    -- Beyond string bounds
    assert(string.sub(s, 100) == "")
    assert(string.sub(s, 1, 100) == "hello")
    assert(string.sub(s, -100) == "hello")
    assert(string.sub(s, -100, 100) == "hello")
    -- Zero index
    assert(string.sub(s, 0) == "hello")
    assert(string.sub(s, 0, 0) == "")
    -- Reversed indices
    assert(string.sub(s, 5, 1) == "")
end)

tests:it("string.find with special pattern chars", function()
    local s = "hello.world"
    -- Find literal dot
    assert(string.find(s, ".", 1, true) == 6)
    -- Find pattern dot (matches any char)
    assert(string.find(s, ".") == 1)
    
    -- Special pattern characters
    local special = "a+b*c?d"
    assert(string.find(special, "+", 1, true) == 2)
    assert(string.find(special, "*", 1, true) == 4)
    assert(string.find(special, "?", 1, true) == 6)
end)

tests:it("string.gsub with empty pattern", function()
    local s = "hello"
    -- Empty match inserts between each char
    local r, n = string.gsub(s, "", "-")
    assert(r == "-h-e-l-l-o-")
    assert(n == 6)
end)

tests:it("string.gsub replacement count limit", function()
    local s = "aaaa"
    local r, n = string.gsub(s, "a", "b", 2)
    assert(r == "bbaa")
    assert(n == 2)
end)

tests:it("string.byte edge cases", function()
    local s = "abc"
    -- No indices returns first byte
    assert(string.byte(s) == 97)
    -- Beyond string bounds
    assert(string.byte(s, 10) == nil)
    -- Negative index
    assert(string.byte(s, -1) == 99)
    -- Multiple bytes beyond end
    local a, b, c, d = string.byte(s, 1, 5)
    assert(a == 97 and b == 98 and c == 99 and d == nil)
end)

tests:it("string.char edge cases", function()
    assert(string.char() == "")
    assert(string.char(0) == "\0")
    assert(string.char(255) == "\255")
end)

tests:it("string.format edge cases", function()
    -- %s with non-string
    assert(string.format("%s", 123) == "123")
    assert(string.format("%s", true) == "true")
    assert(string.format("%s", nil) == "nil")
    
    -- Width and precision
    assert(string.format("%10s", "hi") == "        hi")
    assert(string.format("%-10s", "hi") == "hi        ")
    assert(string.format("%.3s", "hello") == "hel")
    
    -- Integer formats
    assert(string.format("%05d", 42) == "00042")
    assert(string.format("%+d", 42) == "+42")
    assert(string.format("% d", 42) == " 42")
end)

tests:it("string.format error cases", function()
    -- Missing argument
    checkerror("no value", string.format, "%d")
end)

tests:it("string.pack error cases", function()
    -- Invalid format
    checkerror("invalid format", string.pack, "%")
    
    -- Value out of range for format
    checkerror("overflow", string.pack, "b", 200)  -- signed byte max is 127
end)

tests:it("string.unpack error cases", function()
    -- Not enough data
    checkerror("data string too short", string.unpack, "i4", "ab")
    
    -- Invalid format
    checkerror("invalid format", string.unpack, "%", "test")
end)

tests:it("string with embedded nulls", function()
    local s = "hello\0world"
    assert(#s == 11)
    assert(string.byte(s, 6) == 0)
    assert(string.sub(s, 7) == "world")
    assert(string.find(s, "\0") == 6)
end)

tests:it("string.match captures", function()
    -- Multiple captures
    local a, b, c = string.match("hello world test", "(%w+) (%w+) (%w+)")
    assert(a == "hello" and b == "world" and c == "test")
    
    -- No captures returns whole match
    assert(string.match("hello", "l+") == "ll")
    
    -- Position capture
    local pos = string.match("hello", "()l")
    assert(pos == 3)
end)

tests:it("string.gmatch iteration", function()
    local count = 0
    local words = {}
    for w in string.gmatch("hello world test", "%w+") do
        count = count + 1
        words[count] = w
    end
    assert(count == 3)
    assert(words[1] == "hello" and words[2] == "world" and words[3] == "test")
end)

tests:it("string.gmatch with captures", function()
    local pairs_t = {}
    for k, v in string.gmatch("a=1,b=2,c=3", "(%w+)=(%w+)") do
        pairs_t[k] = v
    end
    assert(pairs_t.a == "1" and pairs_t.b == "2" and pairs_t.c == "3")
end)

tests:it("very long string concatenation", function()
    local parts = {}
    for i = 1, 1000 do
        parts[i] = tostring(i)
    end
    local s = table.concat(parts)
    assert(#s > 0)
    assert(string.sub(s, 1, 1) == "1")
end)

tests:finish()
