global print, require, assert, type, _G, table, load, debug, coroutine, math, setmetatable, getmetatable, select, error, string, rawget, rawset, collectgarbage, pairs, ipairs, f, xpcall, t, fat, deep, pledge

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local debug = require "debug"
local tests = framework.new("calls")

tests:it("type checks", function()
    assert(type(1<2) == 'boolean')
    assert(type(true) == 'boolean' and type(false) == 'boolean')
    assert(type(nil) == 'nil'
       and type(-3) == 'number'
       and type'x' == 'string'
       and type{} == 'table'
       and type(type) == 'function')
    assert(type(assert) == type(print))
    
    local ok = catch type(nil)
    assert(ok) -- type(nil) is valid
    
    assert(not (catch type()))  -- type() with no args should error
end)

tests:it("local function recursion", function()
  local res = 1
  local function fact (n)
    if n==0 then return res
    else return n*fact(n-1)
    end
  end
  assert(fact(5) == 120)
end)

tests:it("declarations and method calls", function()
    local a = {i = 10}
    local self = 20
    function a:x (x) return x+self.i end
    function a.y (x) return x+self end
    
    assert(a:x(1)+10 == a.y(1))
    
    a.t = {i=-100}
    a["t"].x = function (self, a,b) return self.i+a+b end
    
    assert(a.t:x(2,3) == -95)
end)

tests:it("method chaining", function()
  local a = {x=0}
  function a:add (x) self.x, a.y = self.x+x, 20; return self end
  assert(a:add(10):add(20):add(30).x == 60 and a.y == 20)
end)

tests:it("nested object functions", function()
    local a = {b={c={}}}
    
    function a.b.c.f1 (x) return x+1 end
    function a.b.c:f2 (x,y) self[x] = y end
    assert(a.b.c.f1(4) == 5)
    a.b.c:f2('k', 12); assert(a.b.c.k == 12)
end)

tests:it("function arguments", function()
  t = nil
  function f(a,b,c) local d = 'a'; t={a,b,c,d} end

  f(1,2)
  assert(t[1] == 1 and t[2] == 2 and t[3] == nil and t[4] == 'a')
  f(1,2,3,4)
  assert(t[1] == 1 and t[2] == 2 and t[3] == 3 and t[4] == 'a')
  t = nil
end)

tests:it("load and function loading", function()
    function fat(x)
      if x <= 1 then return 1
      else return x*load("return fat(" .. x-1 .. ")", "")()
      end
    end
    
    assert(load "load 'assert(fat(6)==720)' () ")()
    local a = load('return fat(5), 3')
    local a,b = a()
    assert(a == 120 and b == 3)
    fat = nil
end)

tests:it("error handling with catch", function()
    local function err_on_n (n)
      if n==0 then error("oops")
      else err_on_n (n-1)
      end
    end
    
    local function dummy (n)
        if n > 0 then
          local ok = catch err_on_n(n)
          assert(not ok)
          dummy(n-1)
        end
    end
    dummy(10)
end)

tests:it("deep recursion", function()
    local function deep (n)
      if n>0 then deep(n-1) end
    end
    deep(10)
    deep(180)
end)

tests:it("tail calls", function()
    local function deep (n) if n>0 then return deep(n-1) else return 101 end end
    assert(deep(30000) == 101)
    local a = {}
    function a:deep (n) if n>0 then return self:deep(n-1) else return 101 end end
    assert(a:deep(30000) == 101)
end)

tests:it("tail calls with varargs", function()
    local function foo (x, ...) local a = {...}; return x, a[1], a[2] end

    local function foo1 (x) return foo(10, x, x + 1) end

    local a, b, c = foo1(-2)
    assert(a == 10 and b == -2 and c == -1)

    -- tail calls x metamethods
    local t = setmetatable({}, {__call = foo})
    local function foo2 (x) return t(10, x) end
    a, b, c = foo2(100)
    assert(a == t and b == 10 and c == 100)

    a, b = (function () return foo() end)()
    assert(a == nil and b == nil)

    local X, Y, A
    local function foo3 (x, y, ...) X = x; Y = y; A = {...} end
    local function foo1 (...) return foo3(...) end

    local a, b, c = foo1()
    assert(X == nil and Y == nil and #A == 0)

    a, b, c = foo1(10)
    assert(X == 10 and Y == nil and #A == 0)

    a, b, c = foo1(10, 20)
    assert(X == 10 and Y == 20 and #A == 0)

    a, b, c = foo1(10, 20, 30)
    assert(X == 10 and Y == 20 and #A == 1 and A[1] == 30)
end)

tests:it("chains of __call", function()
    local n = 10000   -- depth

    local function foo ()
      if n == 0 then return 1023
      else n = n - 1; return foo()
      end
    end

    -- build a chain of __call metamethods ending in function 'foo'
    for i = 1, 15 do
      foo = setmetatable({}, {__call = foo})
    end

    -- call the first one as a tail call in a new coroutine
    assert(coroutine.wrap(function() return foo() end)() == 1023)
end)

tests:it("__call chains with table.pack", function()
    local N = 15
    local u = table.pack
    for i = 1, N do
      u = setmetatable({i}, {__call = u})
    end

    local Res = u("a", "b", "c")

    assert(Res.n == N + 3)
    for i = 1, N do
      assert(Res[i][1] == i)
    end
    assert(Res[N + 1] == "a" and Res[N + 2] == "b" and Res[N + 3] == "c")
end)

tests:it("chains too long", function()
    local a = {}
    for i = 1, 16 do    -- one too many
      a = setmetatable({}, {__call = a})
    end
    local status, msg = catch a()
    assert(not status and string.find(msg, "too long"))

    setmetatable(a, {__call = a})   -- infinite chain
    status, msg = catch a()
    assert(not status and string.find(msg, "too long"))
end)

tests:it("closures fixed-point", function()
    -- fixed-point operator
    local Z = function (le)
          local function a (f)
            return le(function (x) return f(f)(x) end)
          end
          return a(a)
        end

    -- non-recursive factorial
    local F = function (f)
          return function (n)
                   if n == 0 then return 1
                   else return n*f(n-1) end
                 end
        end

    local fat = Z(F)
    assert(fat(0) == 1 and fat(4) == 24 and Z(F)(5)==5*Z(F)(4))
end)

tests:it("multiple returns", function()
    local function unlpack (t, i)
      i = i or 1
      if (i <= #t) then
        return t[i], unlpack(t, i+1)
      end
    end
    
    local function equaltab (t1, t2)
      assert(#t1 == #t2)
      for i = 1, #t1 do
        assert(t1[i] == t2[i])
      end
    end
    
    local pack = function (...) return (table.pack(...)) end
    
    local function f() return 1,2,30,4 end
    local function ret2 (a,b) return a,b end
    
    local a,b,c,d = unlpack{1,2,3}
    assert(a==1 and b==2 and c==3 and d==nil)
    local a = {1,2,3,4,false,10,'alo',false,assert}
    equaltab(pack(unlpack(a)), a)
    equaltab(pack(unlpack(a), -1), {1,-1})
    a,b,c,d = ret2(f()), ret2(f())
    assert(a==1 and b==1 and c==2 and d==nil)
end)

tests:it("extra arguments ignored", function()
    -- testing calls with 'incorrect' arguments
    rawget({}, "x", 1)
    rawset({}, "x", 1, 2)
    assert(math.sin(1,2) == math.sin(1))
    table.sort({10,9,8,4,19,23,0,0}, function (a,b) return a<b end, "extra arg")
end)

tests:it("generic load", function()
    local x = "-- a comment\0\0\0\n  x = 10 + \n23; \
         local a = function () x = 'hi' end; \
         return '\\0'"
    local function read1 (str)
      local i = 0
      return function ()
        collectgarbage()
        i=i+1
        return string.sub(str, i, i)
      end
    end

    local a = assert(load(read1(x), "modname", "t", _G))
    assert(a() == "\0" and _G.x == 33)
    assert(debug.getinfo(a).source == "modname")
    
    -- cannot read text in binary mode - load returns nil + error message
    -- catch wraps the call, so we get (true, nil, error) on success (no throw)
    local status, result, err = catch load(read1(x), "modname", "b", {})
    assert(status == true and result == nil, "load should return nil for binary mode on text")
    
    status, result, err = catch load(x, "modname", "b")
    assert(status == true and result == nil, "load should return nil for binary mode on text")

    a = assert(load(function () return nil end))
    a()  -- empty chunk
    
    _G.x = nil
end)

tests:it("load with nested functions", function()
    local x = [[
      return function (x)
        return function (y)
         return function (z)
           return x+y+z
         end
       end
      end
    ]]
    
    local function read1 (str)
      local i = 0
      return function ()
        i=i+1
        return string.sub(str, i, i)
      end
    end
    
    local a = assert(load(read1(x), "read", "t"))
    assert(a()(2)(3)(10) == 15)
end)

tests:it("parameter adjustment", function()
    assert((function () return nil end)(4) == nil)
    assert((function () local a; return a end)(4) == nil)
    assert((function (a) return a end)() == nil)
end)

tests:it("long method names", function()
    local t = {x = 1}
    function t:_012345678901234567890123456789012345678901234567890123456789 ()
      return self.x
    end
    assert(t:_012345678901234567890123456789012345678901234567890123456789() == 1)
end)

tests:it("limit of multiple returns (254 values)", function()
    local code = "return 10" .. string.rep(",10", 253)
    local res = {assert(load(code))()}
    assert(#res == 254 and res[254] == 10)

    code = code .. ",10"
    -- load returns nil + error for too many returns (doesn't throw)
    local status, result, err = catch load(code)
    -- catch returns (true, nil, error) since load doesn't throw
    assert(status == true, "catch should succeed (load doesn't throw)")
    assert(result == nil, "load should return nil for too many returns")
end)

tests:finish()

