--[[
  Event Loop Test Suite
  Tests coroutine.detach, coroutine.sleep, coroutine.poll, and coroutine.pending
  with Node.js-style async semantics
]]

global print, coroutine, math, os, assert, error, type, tostring, require, table

local framework = require("lus-tests.framework")
local tests = framework.new("Event Loop")

-- ============================================================
-- SECTION 1: Basic API Availability
-- ============================================================

tests:describe("API Availability")

tests:it("coroutine.detach exists", function()
  tests:assert_true(type(coroutine.detach) == "function")
end)

tests:it("coroutine.sleep exists", function()
  tests:assert_true(type(coroutine.sleep) == "function")
end)

tests:it("coroutine.poll exists", function()
  tests:assert_true(type(coroutine.poll) == "function")
end)

tests:it("coroutine.pending exists", function()
  tests:assert_true(type(coroutine.pending) == "function")
end)

tests:it("coroutine.status_e enum exists", function()
  local s = coroutine.status_e
  tests:assert_true(s ~= nil, "status_e should exist")
  tests:assert_true(s.pending ~= nil, "status_e.pending should exist")
  tests:assert_true(s.completed ~= nil, "status_e.completed should exist")
  tests:assert_true(s.yielded ~= nil, "status_e.yielded should exist")
  tests:assert_true(s.error ~= nil, "status_e.error should exist")
end)

-- ============================================================
-- SECTION 2: coroutine.detach Validation
-- ============================================================

tests:describe("coroutine.detach validation")

tests:it("cannot detach dead coroutine", function()
  local co = coroutine.create(function() return 1 end)
  coroutine.resume(co)  -- Run to completion
  
  local ok, err = catch coroutine.detach(co)
  tests:assert_true(not ok, "detaching dead coroutine should fail")
end)

tests:it("detach synchronous coroutine returns completed", function()
  local co = coroutine.create(function() return 42 end)
  local status, result = coroutine.detach(co)
  tests:assert_equal(status, coroutine.status_e.completed)
  tests:assert_equal(result, 42)
end)

tests:it("detach yielding coroutine returns yielded", function()
  local co = coroutine.create(function()
    coroutine.yield("hello")
    return "done"
  end)
  local status, val = coroutine.detach(co)
  tests:assert_equal(status, coroutine.status_e.yielded)
  tests:assert_equal(val, "hello")
end)

tests:it("detach sleeping coroutine returns pending", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.1)
    return "done"
  end)
  local status = coroutine.detach(co)
  tests:assert_equal(status, coroutine.status_e.pending)
  tests:assert_true(coroutine.pending() > 0)
  
  -- Poll to complete
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
end)

-- ============================================================
-- SECTION 3: coroutine.sleep Validation
-- ============================================================

tests:describe("coroutine.sleep validation")

tests:it("sleep fails in non-detached coroutine", function()
  local co = coroutine.create(function()
    local ok, err = catch coroutine.sleep(0.01)
    return ok, err
  end)
  
  local success, ok, err = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_true(not ok, "sleep should fail in non-detached coroutine")
end)

tests:it("sleep with zero duration succeeds immediately", function()
  local executed = false
  local co = coroutine.create(function()
    coroutine.sleep(0)
    executed = true
    return "done"
  end)
  
  local status = coroutine.detach(co)
  -- Zero sleep may yield to pending or complete immediately
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  tests:assert_true(executed)
end)

-- ============================================================
-- SECTION 4: Sleep Timing and Poll
-- ============================================================

tests:describe("Sleep timing and poll")

tests:it("100ms sleep completes after poll", function()
  local completed = false
  local co = coroutine.create(function()
    coroutine.sleep(0.1)
    completed = true
  end)
  
  local status = coroutine.detach(co)
  tests:assert_equal(status, coroutine.status_e.pending)
  
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  tests:assert_true(completed)
end)

tests:it("multiple sleeps in sequence", function()
  local count = 0
  local co = coroutine.create(function()
    coroutine.sleep(0.05)
    count = count + 1
    coroutine.sleep(0.05)
    count = count + 1
    coroutine.sleep(0.05)
    count = count + 1
  end)
  
  coroutine.detach(co)
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  tests:assert_equal(count, 3)
end)

tests:it("multiple parallel sleeps", function()
  local results = {}
  
  local co1 = coroutine.create(function()
    coroutine.sleep(0.05)
    results[1] = "done1"
  end)
  
  local co2 = coroutine.create(function()
    coroutine.sleep(0.05)
    results[2] = "done2"
  end)
  
  coroutine.detach(co1)
  coroutine.detach(co2)
  
  tests:assert_equal(coroutine.pending(), 2)
  
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  
  tests:assert_equal(results[1], "done1")
  tests:assert_equal(results[2], "done2")
end)

-- ============================================================
-- SECTION 5: Error Handling
-- ============================================================

tests:describe("Error handling")

tests:it("immediate error returns error status", function()
  local co = coroutine.create(function()
    error("immediate failure")
  end)
  
  local status, err = coroutine.detach(co)
  tests:assert_equal(status, coroutine.status_e.error)
  tests:assert_true(err:find("immediate failure") ~= nil)
end)

tests:it("error after sleep thrown on poll", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.05)
    error("delayed failure")
  end)
  
  local status = coroutine.detach(co)
  tests:assert_equal(status, coroutine.status_e.pending)
  
  local ok, err = catch coroutine.poll(1)
  tests:assert_true(not ok, "poll should throw error")
  tests:assert_true(err:find("delayed failure") ~= nil)
end)

tests:it("catch allows continued polling", function()
  local results = {}
  
  local co1 = coroutine.create(function()
    coroutine.sleep(0.05)
    error("co1 failed")
  end)
  
  local co2 = coroutine.create(function()
    coroutine.sleep(0.1)
    results[1] = "co2 done"
  end)
  
  coroutine.detach(co1)
  coroutine.detach(co2)
  
  -- Poll and catch errors
  while coroutine.pending() > 0 do
    local ok, err = catch coroutine.poll(1)
    if not ok then
      results[2] = "caught: " .. tostring(err):sub(1, 20)
    end
  end
  
  tests:assert_equal(results[1], "co2 done")
  tests:assert_true(results[2] ~= nil, "should have caught error")
end)

-- ============================================================
-- SECTION 6: State Transitions
-- ============================================================

tests:describe("State transitions")

tests:it("completed coroutine is dead", function()
  local co = coroutine.create(function() return 1 end)
  coroutine.detach(co)
  tests:assert_equal(coroutine.status(co), "dead")
end)

tests:it("pending coroutine is suspended", function()
  local co = coroutine.create(function()
    coroutine.sleep(1)
    return 1
  end)
  coroutine.detach(co)
  tests:assert_equal(coroutine.status(co), "suspended")
  
  -- Cleanup
  coroutine.close(co)
end)

-- ============================================================
-- SECTION 7: Stress tests
-- ============================================================

tests:describe("Stress tests")

tests:it("many small sleeps", function()
  local count = 0
  local co = coroutine.create(function()
    for i = 1, 50 do
      coroutine.sleep(0.001)
      count = count + 1
    end
  end)
  
  coroutine.detach(co)
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  tests:assert_equal(count, 50)
end)

tests:it("many parallel coroutines", function()
  local results = {}
  local coros = {}
  
  for i = 1, 10 do
    local co = coroutine.create(function()
      coroutine.sleep(0.01)
      results[i] = i
    end)
    coros[i] = co
    coroutine.detach(co)
  end
  
  tests:assert_equal(coroutine.pending(), 10)
  
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  
  for i = 1, 10 do
    tests:assert_equal(results[i], i)
  end
end)

-- ============================================================
-- SECTION 8: Edge cases
-- ============================================================

tests:describe("Edge cases")

tests:it("very short sleep (1 microsecond)", function()
  local done = false
  local co = coroutine.create(function()
    coroutine.sleep(0.000001)
    done = true
  end)
  
  coroutine.detach(co)
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  tests:assert_true(done)
end)

tests:it("table passed through detached coroutine", function()
  local tbl = {x = 10, y = 20}
  local result
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    result = tbl
    tbl.z = 30
  end)
  
  coroutine.detach(co)
  while coroutine.pending() > 0 do
    coroutine.poll(1)
  end
  
  tests:assert_equal(result.x, 10)
  tests:assert_equal(result.y, 20)
  tests:assert_equal(result.z, 30)
end)

tests:it("poll with no pending returns immediately", function()
  tests:assert_equal(coroutine.pending(), 0)
  -- Should not block
  coroutine.poll()
  tests:assert_equal(coroutine.pending(), 0)
end)

tests:finish()
