--[[
  Event Loop Test Suite
  Tests coroutine.detach and coroutine.sleep with focus on edge cases
  and common event loop pain points
]]

global print, coroutine, math, os, assert, error, type, tostring, require, table

local framework = require("lus-tests.framework")
local tests = framework.new("Event Loop")

-- ============================================================
-- SECTION 1: Basic API Availability
-- ============================================================

tests:describe("API Availability")

tests:it("coroutine.detach exists", function()
  tests:assert_true(type(coroutine.detach) == "function")
end)

tests:it("coroutine.sleep exists", function()
  tests:assert_true(type(coroutine.sleep) == "function")
end)

-- ============================================================
-- SECTION 2: coroutine.detach Validation
-- ============================================================

tests:describe("coroutine.detach validation")

tests:it("cannot detach dead coroutine", function()
  local co = coroutine.create(function() return 1 end)
  coroutine.resume(co)  -- Run to completion
  
  local ok, err = catch coroutine.detach(co)
  tests:assert_true(not ok, "detaching dead coroutine should fail")
end)

tests:it("can detach suspended coroutine", function()
  local co = coroutine.create(function()
    coroutine.yield()
    return "after yield"
  end)
  
  local ok = coroutine.detach(co)
  tests:assert_true(ok)
end)

tests:it("can detach newly created coroutine", function()
  local co = coroutine.create(function() return 42 end)
  local ok = coroutine.detach(co)
  tests:assert_true(ok)
  
  local success, result = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(result, 42)
end)

-- ============================================================
-- SECTION 3: coroutine.sleep Validation
-- ============================================================

tests:describe("coroutine.sleep validation")

tests:it("sleep fails in non-detached coroutine", function()
  local co = coroutine.create(function()
    local ok, err = catch coroutine.sleep(0.01)
    return ok, err
  end)
  
  local success, ok, err = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_true(not ok, "sleep should fail in non-detached coroutine")
end)

tests:it("sleep with negative duration fails", function()
  local co = coroutine.create(function()
    local ok, err = catch coroutine.sleep(-1)
    return ok, err
  end)
  
  coroutine.detach(co)
  local success, ok, err = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_true(not ok, "negative sleep should fail")
end)

tests:it("sleep with zero duration succeeds immediately", function()
  local executed = false
  local co = coroutine.create(function()
    coroutine.sleep(0)
    executed = true
    return "done"
  end)
  
  coroutine.detach(co)
  local success, result = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_true(executed)
  tests:assert_equal(result, "done")
end)

-- ============================================================
-- SECTION 4: Sleep Timing Accuracy
-- ============================================================

tests:describe("Sleep timing")

-- Note: We verify that sleep returns, and timing is reasonable using os.time (seconds granularity)
tests:it("100ms sleep completes successfully", function()
  local co = coroutine.create(function()
    local before = os.time()
    coroutine.sleep(0.1)
    local after = os.time()
    return after - before
  end)
  
  coroutine.detach(co)
  local success, elapsed = coroutine.resume(co)
  tests:assert_true(success)
  -- os.time has second granularity, so elapsed should be 0 or 1
  tests:assert_true(elapsed >= 0, "sleep returned negative time")
  tests:assert_true(elapsed <= 2, "sleep took too long: " .. tostring(elapsed))
end)

tests:it("multiple consecutive sleeps complete", function()
  local co = coroutine.create(function()
    local count = 0
    coroutine.sleep(0.05)
    count = count + 1
    coroutine.sleep(0.05)
    count = count + 1
    coroutine.sleep(0.05)
    count = count + 1
    return count
  end)
  
  coroutine.detach(co)
  local success, count = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(count, 3)
end)

-- ============================================================
-- SECTION 5: Return Value Handling
-- ============================================================

tests:describe("Return values")

tests:it("single return value preserved", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    return 42
  end)
  
  coroutine.detach(co)
  local success, result = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(result, 42)
end)

tests:it("multiple return values preserved", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    return 1, 2, 3, "four", true
  end)
  
  coroutine.detach(co)
  local success, a, b, c, d, e = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(a, 1)
  tests:assert_equal(b, 2)
  tests:assert_equal(c, 3)
  tests:assert_equal(d, "four")
  tests:assert_equal(e, true)
end)

tests:it("nil return values handled correctly", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    return nil, nil, "end"
  end)
  
  coroutine.detach(co)
  local success, a, b, c = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(a, nil)
  tests:assert_equal(b, nil)
  tests:assert_equal(c, "end")
end)

-- ============================================================
-- SECTION 6: Error Propagation
-- ============================================================

tests:describe("Error handling")

tests:it("error before sleep propagates", function()
  local co = coroutine.create(function()
    error("early error")
    coroutine.sleep(0.01)
  end)
  
  coroutine.detach(co)
  -- Use catch to capture the error from resume
  local ok, err = catch coroutine.resume(co)
  tests:assert_true(not ok, "resume should fail on error")
end)

tests:it("error after sleep propagates", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    error("late error")
  end)
  
  coroutine.detach(co)
  -- Use catch to capture the error from resume
  local ok, err = catch coroutine.resume(co)
  tests:assert_true(not ok, "resume should fail on error")
end)

-- ============================================================
-- SECTION 7: Coroutine State Transitions
-- ============================================================

tests:describe("State transitions")

tests:it("detached coroutine can complete and become dead", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    return "done"
  end)
  
  coroutine.detach(co)
  tests:assert_equal(coroutine.status(co), "suspended")
  
  coroutine.resume(co)
  tests:assert_equal(coroutine.status(co), "dead")
end)

tests:it("coroutine.close works on detached coroutine", function()
  local co = coroutine.create(function()
    coroutine.yield()  -- Will never be reached after close
    coroutine.sleep(1.0)
  end)
  
  coroutine.detach(co)
  local ok = coroutine.close(co)
  tests:assert_true(ok)
  tests:assert_equal(coroutine.status(co), "dead")
end)

-- ============================================================
-- SECTION 8: Normal Yield in Detached Coroutine
-- ============================================================

tests:describe("Normal yield in detached coroutine")

tests:it("yield without sleep returns to caller", function()
  local co = coroutine.create(function()
    coroutine.yield("yielded")
    return "finished"
  end)
  
  coroutine.detach(co)
  
  local success1, val1 = coroutine.resume(co)
  tests:assert_true(success1)
  tests:assert_equal(val1, "yielded")
  tests:assert_equal(coroutine.status(co), "suspended")
  
  local success2, val2 = coroutine.resume(co)
  tests:assert_true(success2)
  tests:assert_equal(val2, "finished")
  tests:assert_equal(coroutine.status(co), "dead")
end)

tests:it("mixed yield and sleep", function()
  local steps = {}
  local co = coroutine.create(function()
    table.insert(steps, "start")
    coroutine.yield("y1")
    table.insert(steps, "after y1")
    coroutine.sleep(0.01)
    table.insert(steps, "after sleep")
    coroutine.yield("y2")
    table.insert(steps, "after y2")
    return "done"
  end)
  
  coroutine.detach(co)
  
  local ok, r1 = coroutine.resume(co)
  tests:assert_true(ok)
  tests:assert_equal(r1, "y1")
  tests:assert_equal(#steps, 1)
  
  local ok2, r2 = coroutine.resume(co)
  tests:assert_true(ok2)
  tests:assert_equal(r2, "y2")
  tests:assert_equal(#steps, 3)  -- after y1, after sleep
  
  local ok3, r3 = coroutine.resume(co)
  tests:assert_true(ok3)
  tests:assert_equal(r3, "done")
  tests:assert_equal(#steps, 4)
end)

-- ============================================================
-- SECTION 9: Arguments to Resume
-- ============================================================

tests:describe("Resume arguments")

tests:it("initial arguments passed to coroutine function", function()
  local co = coroutine.create(function(a, b, c)
    coroutine.sleep(0.01)
    return a + b + c
  end)
  
  coroutine.detach(co)
  local success, result = coroutine.resume(co, 1, 2, 3)
  tests:assert_true(success)
  tests:assert_equal(result, 6)
end)

tests:it("resume arguments passed through yield", function()
  local co = coroutine.create(function()
    local x = coroutine.yield()
    coroutine.sleep(0.01)
    return x * 2
  end)
  
  coroutine.detach(co)
  coroutine.resume(co)  -- Start, hits yield
  local success, result = coroutine.resume(co, 21)  -- Pass 21 through yield
  tests:assert_true(success)
  tests:assert_equal(result, 42)
end)

-- ============================================================
-- SECTION 10: Stress Tests
-- ============================================================

tests:describe("Stress tests")

tests:it("many small sleeps", function()
  local co = coroutine.create(function()
    local count = 0
    for i = 1, 20 do
      coroutine.sleep(0.001)  -- 1ms each
      count = count + 1
    end
    return count
  end)
  
  coroutine.detach(co)
  local success, count = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(count, 20)
end)

tests:it("detach and resume immediately multiple times", function()
  for i = 1, 10 do
    local co = coroutine.create(function()
      coroutine.sleep(0.001)
      return i
    end)
    coroutine.detach(co)
    local success, result = coroutine.resume(co)
    tests:assert_true(success)
    tests:assert_equal(result, i)
  end
end)

-- ============================================================
-- SECTION 11: Edge Cases
-- ============================================================

tests:describe("Edge cases")

tests:it("detach same coroutine twice is idempotent", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    return "ok"
  end)
  
  local ok1 = coroutine.detach(co)
  local ok2 = coroutine.detach(co)
  tests:assert_true(ok1)
  tests:assert_true(ok2)
  
  local success, result = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(result, "ok")
end)

tests:it("very short sleep (1 microsecond)", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.000001)  -- 1 microsecond
    return "fast"
  end)
  
  coroutine.detach(co)
  local success, result = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(result, "fast")
end)

tests:it("table passed through detached coroutine", function()
  local co = coroutine.create(function()
    coroutine.sleep(0.01)
    return {key = "value", nested = {a = 1}}
  end)
  
  coroutine.detach(co)
  local success, result = coroutine.resume(co)
  tests:assert_true(success)
  tests:assert_equal(result.key, "value")
  tests:assert_equal(result.nested.a, 1)
end)

-- Run all tests
tests:finish()
