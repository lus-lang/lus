global print, require, assert, type, string, table, vector, pledge, math, tostring

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("vectors")

-- Basic creation
tests:it("basic creation", function()
  local v = vector.create(1024)
  assert(#v == 1024, "length should be 1024")
  assert(vector.size(v) == 1024, "size should be 1024")
  assert(type(v) == "vector", "type should be vector")
end)

-- Fast creation (uninitialized)
tests:it("fast creation", function()
  local v = vector.create(512, true)
  assert(#v == 512, "length should be 512")
end)

-- Zero-length vector
tests:it("zero-length vector", function()
  local v = vector.create(0)
  assert(#v == 0, "length should be 0")
end)

-- Pack/unpack single integer
tests:it("pack unpack integer", function()
  local v = vector.create(8)
  vector.pack(v, 0, "I4", 123456789)
  local val = vector.unpack(v, 0, "I4")
  assert(val == 123456789, "should unpack same value")
end)

-- Pack/unpack multiple integers
tests:it("pack unpack multiple", function()
  local v = vector.create(16)
  vector.pack(v, 0, "I4I4I4", 1, 2, 3)
  local a, b, c = vector.unpack(v, 0, "I4I4I4")
  assert(a == 1 and b == 2 and c == 3, "should unpack all values")
end)

-- Pack/unpack bytes
tests:it("pack unpack bytes", function()
  local v = vector.create(4)
  vector.pack(v, 0, "BBBB", 10, 20, 30, 40)
  local a, b, c, d = vector.unpack(v, 0, "BBBB")
  assert(a == 10 and b == 20 and c == 30 and d == 40, "should unpack bytes")
end)

-- Pack/unpack float
tests:it("pack unpack float", function()
  local v = vector.create(8)
  vector.pack(v, 0, "f", 3.14)
  local val = vector.unpack(v, 0, "f")
  assert(math.abs(val - 3.14) < 0.01, "should unpack float approximately")
end)

-- Pack/unpack double
tests:it("pack unpack double", function()
  local v = vector.create(16)
  vector.pack(v, 0, "d", 3.141592653589793)
  local val = vector.unpack(v, 0, "d")
  assert(math.abs(val - 3.141592653589793) < 0.0001, "should unpack double")
end)

-- Pack/unpack fixed-size string
tests:it("pack unpack string", function()
  local v = vector.create(10)
  vector.pack(v, 0, "c5", "hello")
  local val = vector.unpack(v, 0, "c5")
  assert(val == "hello", "should unpack string")
end)

-- Clone
tests:it("clone vector", function()
  local v = vector.create(8)
  vector.pack(v, 0, "I4", 42)
  local v2 = vector.clone(v)
  assert(#v2 == #v, "clone should have same length")
  assert(vector.unpack(v2, 0, "I4") == 42, "clone should have same data")
end)

-- Resize (grow)
tests:it("resize grow", function()
  local v = vector.create(8)
  vector.pack(v, 0, "I4", 999)
  vector.resize(v, 16)
  assert(#v == 16, "size should be 16 after resize")
  assert(vector.unpack(v, 0, "I4") == 999, "original data should be preserved")
end)

-- Resize (shrink)
tests:it("resize shrink", function()
  local v = vector.create(16)
  vector.pack(v, 0, "I4", 888)
  vector.resize(v, 8)
  assert(#v == 8, "size should be 8 after resize")
  assert(vector.unpack(v, 0, "I4") == 888, "data in range should be preserved")
end)

-- Slice forward
tests:it("slice forward", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)
  end
  local s = v[3, 7]  -- bytes 3-7 (values 3-7)
  assert(#s == 5, "slice length should be 5")
  assert(vector.unpack(s, 0, "B") == 3, "first byte should be 3")
  assert(vector.unpack(s, 4, "B") == 7, "last byte should be 7")
end)

-- Slice reverse
tests:it("slice reverse", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)
  end
  local s = v[7, 3]  -- reverse: bytes 7 down to 3
  assert(#s == 5, "slice length should be 5")
  assert(vector.unpack(s, 0, "B") == 7, "first byte should be 7 (reversed)")
  assert(vector.unpack(s, 4, "B") == 3, "last byte should be 3 (reversed)")
end)

-- Slice from start
tests:it("slice from start", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)
  end
  local s = v[, 5]  -- bytes 1-5
  assert(#s == 5, "slice length should be 5")
  assert(vector.unpack(s, 0, "B") == 1, "first byte should be 1")
end)

-- Slice to end
tests:it("slice to end", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)
  end
  local s = v[6, ]  -- bytes 6-10
  assert(#s == 5, "slice length should be 5")
  assert(vector.unpack(s, 0, "B") == 6, "first byte should be 6")
end)

-- Slice full copy
tests:it("slice full copy", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)
  end
  local s = v[, ]  -- full copy
  assert(#s == 10, "full slice should have same length")
end)

-- Endianness test (simplified)
tests:it("endianness", function()
  local v = vector.create(8)
  vector.pack(v, 0, "<I4", 0x12345678)  -- little endian
  local b1, b2 = vector.unpack(v, 0, "BB")
  assert(b1 == 0x78 and b2 == 0x56, "little endian should have LSB first")
  
  vector.pack(v, 0, ">I4", 0x12345678)  -- big endian
  b1, b2 = vector.unpack(v, 0, "BB")
  assert(b1 == 0x12 and b2 == 0x34, "big endian should have MSB first")
end)

-- unpackmany iterator
tests:it("unpackmany iterator", function()
  local v = vector.create(12)
  vector.pack(v, 0, "I4", 10)
  vector.pack(v, 4, "I4", 20)
  vector.pack(v, 8, "I4", 30)
  local sum = 0
  local count = 0
  for val in vector.unpackmany(v, 0, "I4") do
    sum = sum + val
    count = count + 1
  end
  assert(count == 3, "should have 3 iterations, got " .. count)
  assert(sum == 60, "sum should be 60")
end)

-- ============================================
-- Negative/Error Case Tests
-- ============================================

tests:it("pack out of bounds", function()
  local v = vector.create(4)
  -- Packing beyond vector size should error
  local ok, err = catch vector.pack(v, 2, "I4", 123)
  assert(not ok, "should error when packing beyond bounds")
end)

tests:it("unpack out of bounds", function()
  local v = vector.create(4)
  vector.pack(v, 0, "I4", 42)
  -- Unpacking beyond vector size should error
  local ok, err = catch vector.unpack(v, 2, "I4")
  assert(not ok, "should error when unpacking beyond bounds")
end)

tests:it("negative offset errors", function()
  local v = vector.create(8)
  local ok, err = catch vector.pack(v, -1, "I4", 123)
  assert(not ok, "should error with negative offset")
end)

tests:it("invalid format string", function()
  local v = vector.create(8)
  local ok, err = catch vector.pack(v, 0, "%", 123)
  assert(not ok, "should error with invalid format")
end)

tests:it("operations on zero-size vector", function()
  local v = vector.create(0)
  assert(#v == 0, "zero-size vector should have length 0")
  
  -- Can't pack anything into zero-size
  local ok, err = catch vector.pack(v, 0, "B", 1)
  assert(not ok, "should error packing into zero-size vector")
  
  -- Can't unpack anything from zero-size
  local ok2, err2 = catch vector.unpack(v, 0, "B")
  assert(not ok2, "should error unpacking from zero-size vector")
end)

tests:it("resize to zero", function()
  local v = vector.create(8)
  vector.pack(v, 0, "I4", 42)
  vector.resize(v, 0)
  assert(#v == 0, "resized vector should have length 0")
end)

tests:it("clone of zero-size vector", function()
  local v = vector.create(0)
  local c = vector.clone(v)
  assert(#c == 0, "clone of zero-size should be zero-size")
end)

tests:it("slice with invalid indices clamps to bounds", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)  -- pack values 1-10 at offsets 0-9
  end
  
  -- Slice beyond bounds clamps to valid range
  -- Vector slices use 1-based inclusive indices
  -- v[5,20] means bytes 5-10 (1-based), which is 0-based offsets 4-9 = 6 bytes
  local s = v[5, 20]
  assert(#s == 6, "slice should clamp to valid range, got length " .. #s)
  -- First byte of slice is original offset 4 which has value 5
  assert(vector.unpack(s, 0, "B") == 5, "first element should be 5")
  -- Last byte of slice is original offset 9 which has value 10
  assert(vector.unpack(s, 5, "B") == 10, "last element should be 10")
end)

tests:it("slice with negative indices returns empty", function()
  local v = vector.create(10)
  for i = 0, 9 do
    vector.pack(v, i, "B", i + 1)
  end
  
  -- Negative indices return empty vector in Lus
  local s = v[-5, -1]
  assert(type(s) == "vector", "result should be a vector")
  assert(#s == 0, "negative index slice should be empty")
end)

tests:it("resize larger preserves data", function()
  local v = vector.create(4)
  vector.pack(v, 0, "I4", 0x12345678)
  vector.resize(v, 16)
  assert(#v == 16, "size should be 16")
  assert(vector.unpack(v, 0, "I4") == 0x12345678, "original data preserved")
end)

tests:it("resize smaller truncates", function()
  local v = vector.create(16)
  vector.pack(v, 0, "I4", 0x11111111)
  vector.pack(v, 4, "I4", 0x22222222)
  vector.pack(v, 8, "I4", 0x33333333)
  vector.resize(v, 8)
  assert(#v == 8, "size should be 8")
  assert(vector.unpack(v, 0, "I4") == 0x11111111, "first int preserved")
  assert(vector.unpack(v, 4, "I4") == 0x22222222, "second int preserved")
  -- Third int is truncated
end)

tests:it("pack string too long for fixed size errors", function()
  local v = vector.create(10)
  -- Packing a string longer than the format specifies should error
  local ok, err = catch vector.pack(v, 0, "c3", "hello")
  assert(not ok, "should error when string is longer than format size")
  assert(tostring(err):find("longer than given size"), "error should mention size mismatch")
end)

tests:it("unpack string from insufficient data", function()
  local v = vector.create(3)
  vector.pack(v, 0, "c3", "abc")
  -- Try to unpack more than available
  local ok, err = catch vector.unpack(v, 0, "c10")
  assert(not ok, "should error when unpacking more than available")
end)

tests:it("multiple pack/unpack operations", function()
  local v = vector.create(100)
  
  -- Pack various types at various offsets
  vector.pack(v, 0, "B", 255)
  vector.pack(v, 1, "h", -1000)
  vector.pack(v, 3, "I4", 123456789)
  vector.pack(v, 7, "d", 3.14159265358979)
  vector.pack(v, 15, "c5", "hello")
  
  -- Unpack and verify
  assert(vector.unpack(v, 0, "B") == 255)
  assert(vector.unpack(v, 1, "h") == -1000)
  assert(vector.unpack(v, 3, "I4") == 123456789)
  assert(math.abs(vector.unpack(v, 7, "d") - 3.14159265358979) < 0.0000001)
  assert(vector.unpack(v, 15, "c5") == "hello")
end)

tests:it("unpackmany on empty vector", function()
  local v = vector.create(0)
  local count = 0
  for val in vector.unpackmany(v, 0, "I4") do
    count = count + 1
  end
  assert(count == 0, "should have 0 iterations on empty vector")
end)

tests:it("unpackmany with offset", function()
  local v = vector.create(16)
  vector.pack(v, 0, "I4", 1)
  vector.pack(v, 4, "I4", 2)
  vector.pack(v, 8, "I4", 3)
  vector.pack(v, 12, "I4", 4)
  
  -- Start from offset 4
  local sum = 0
  for val in vector.unpackmany(v, 4, "I4") do
    sum = sum + val
  end
  assert(sum == 2 + 3 + 4, "should unpack from offset 4: " .. sum)
end)

tests:finish()
