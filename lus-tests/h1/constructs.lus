global print, require, assert, type, math, table, string, tostring, table, math, ipairs, pairs, io, _G, select, tonumber, load, error, debug, pledge

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local debug = require "debug"
local tests = framework.new("constructs")

local function checkload (s, msg)
  local ok, f, err = catch load(s)
  if not ok then
    assert(string.find(f, msg), "Expected '"..msg.."' in '"..tostring(f).."'")
    return
  end
  if not f then
    assert(string.find(err, msg), "Expected '"..msg.."' in '"..tostring(err).."'")
  else
    error("Should fail: " .. s)
  end
end

tests:it("semicolons", function()
    local a
    do ;;; end
    ; do ; a = 3; assert(a == 3) end;
    ;
end)

tests:it("invalid operations not executed", function()
    -- invalid operations should not raise errors when not executed
    local a
    if false then a = 3 // 0; a = 0 % 0 end
end)

tests:it("priorities", function()
    assert(2^3^2 == 2^(3^2));
    assert(2^3*4 == (2^3)*4);
    assert(2.0^-2 == 1/4 and -2^- -2 == - - -4);
    assert(not nil and 2 and not(2>3 or 3<2));
    assert(-3-1-5 == 0+0-9);
    assert(-2^2 == -4 and (-2)^2 == 4 and 2*2-3-1 == 0);
    assert(-3%5 == 2 and -3+5 == 2)
    assert(2*1+3/3 == 3 and 1+2 .. 3*1 == "33");
    assert(not(2+1 > 3*1) and "a".."b" > "a");
    
    assert(0xF0 | 0xCC ~ 0xAA & 0xFD == 0xF4)
    assert(0xFD & 0xAA ~ 0xCC | 0xF0 == 0xF4)
    assert(0xF0 & 0x0F + 1 == 0x10)
    
    assert(3^4//2^3//5 == 2)
    assert(-3+4*5//2^3^2//9+4%10/3 == (-3)+(((4*5)//(2^(3^2)))//9)+((4%10)/3))
end)

tests:it("short-circuit logic", function()
    assert(not ((true or false) and nil))
    assert(      true or false  and nil)
    
    -- old bug
    assert((((1 or false) and true) or false) == true)
    assert((((nil and true) or false) and true) == false)
    
    local a,b = 1,nil;
    assert(-(1 or 2) == -1 and (1 and 2)+(-1.25 or -4) == 0.75);
    local x = ((b or a)+1 == 2 and (10 or a)+1 == 11); assert(x);
    x = (((2<3) or 1) == true and (2<3 and 4) == 4); assert(x);

    local x, y = 1, 2;
    assert((x>y) and x or y == 2);
    x,y=2,1;
    assert((x>y) and x or y == 2);
end)

tests:it("tonumber and large integers", function()
     assert(1234567890 == tonumber('1234567890') and 1234567890+1 == 1234567891)
end)

tests:it("silly loops", function()
    repeat until 1; repeat until true;
    while false do end; while nil do end;
end)

tests:it("upvalue in first position", function()
    -- test old bug (first name could not be an `upvalue')
    local a; local function f(x) x={a=1}; x={x=1}; x={G=1} end
end)

tests:it("multiple return expansion", function()
    local function f (i)
      if type(i) ~= 'number' then return i,'jojo'; end;
      if i > 0 then return i, f(i-1); end;
    end
    
    local x = {f(3), f(5), f(10);};
    assert(x[1] == 3 and x[2] == 5 and x[3] == 10 and x[4] == 9 and x[12] == 1);
    assert(x[nil] == nil)
    x = {f'alo', f'xixi', nil};
    assert(x[1] == 'alo' and x[2] == 'xixi' and x[3] == nil);
    x = {f'alo'..'xixi'};
    assert(x[1] == 'aloxixi')
    x = {f{}}
    assert(x[2] == 'jojo' and type(x[1]) == 'table')
end)

tests:it("if-elseif chains", function()
    local f = function (i)
      if i < 10 then return 'a';
      elseif i < 20 then return 'b';
      elseif i < 30 then return 'c';
      end;
    end
    
    assert(f(3) == 'a' and f(12) == 'b' and f(26) == 'c' and f(100) == nil)
end)

tests:it("nested for loops", function()
    for i=1,1000 do break; end;
    local n=100;
    local i=3;
    local t = {};
    local a=nil
    while not a do
      a=0; for i=1,n do for i=i,1,-1 do a=a+1; t[i]=1; end; end;
    end
    assert(a == n*(n+1)/2 and i==3);
    assert(t[1] and t[n] and not t[0] and not t[n+1])
end)

tests:it("repeat-until with break and local", function()
    local function f(b)
      local x = 1;
      repeat
        local a;
        if b==1 then local b=1; x=10; break
        elseif b==2 then x=20; break;
        elseif b==3 then x=30;
        else local a,b,c,d=math.sin(1); x=x+1;
        end
      until x>=12;
      return x;
    end
    
    assert(f(1) == 10 and f(2) == 20 and f(3) == 30 and f(4)==12)
end)

tests:it("if-elseif with else", function()
    local f = function (i)
      if i < 10 then return 'a'
      elseif i < 20 then return 'b'
      elseif i < 30 then return 'c'
      else return 8
      end
    end
    
    assert(f(3) == 'a' and f(12) == 'b' and f(26) == 'c' and f(100) == 8)
end)

tests:it("expression evaluation in tables", function()
    local a, b = nil, 23
    local f = function(i) if i < 10 then return 'a' else return 8 end end
    local x = {f(100)*2+3 or a, a or b+2}
    assert(x[1] == 19 and x[2] == 25)
    x = {f=2+3 or a, a = b+2}
    assert(x.f == 5 and x.a == 25)
    
    a={y=1}
    x = {a.y}
    assert(x[1] == 1)
end)

tests:it("while loop with breaks", function()
    local function f (i)
      while 1 do
        if i>0 then i=i-1;
        else return; end;
      end;
    end

    local function g(i)
      while 1 do
        if i>0 then i=i-1
        else return end
      end
    end

    f(10); g(10);
end)

tests:it("multiple return adjustment", function()
    local function f () return 1,2,3; end
    local a, b, c = f();
    assert(a==1 and b==2 and c==3)
    a, b, c = (f());
    assert(a==1 and b==nil and c==nil)
    
    local a,b = 3 and f();
    assert(a==1 and b==nil)

    local function g() f(); return; end;
    assert(g() == nil)
    local function h() return nil or f() end
    a,b = h()
    assert(a==1 and b==nil)
end)

tests:it("constants validation", function()
    -- With runtime attributes, <XXX> is a valid expression (variable lookup).
    -- If XXX is nil at runtime, it errors when trying to call it as a handler.
    -- This is a runtime error, so we need to actually run the code.
    local ok, f = catch load([[local x <XXX> = 10]])
    if ok and f then
        local rok, err = catch f()
        assert(not rok and string.find(err, "attempt to call a nil value"),
               "Expected runtime error for nil attribute")
    end

    checkload([[local xxx <const> = 20; xxx = 10]],
               "attempt to assign to const variable")

    checkload([[
      local x <close> = nil
      x = io.open()
    ]], "attempt to assign to const variable")
end)

tests:it("complex boolean expressions", function()
    local f = [[
    return function ( a , b , c , d , e )
      local x = a >= b or c or ( d and e ) or nil
      return x
    end , { a = 1 , b = 2 >= 1 , } or { 1 };
    ]]
    f = string.gsub(f, "%s+", "\n");
    local f,a = load(f)();
    assert(a.a == 1 and a.b)

    local function g (a,b,c,d,e)
      if not (a>=b or c or d and e or nil) then return 0; else return 1; end;
    end

    local function h (a,b,c,d,e)
      while (a>=b or c or (d and e) or nil) do return 1; end;
      return 0;
    end

    assert(f(2,1) == true and g(2,1) == 1 and h(2,1) == 1)
    assert(f(1,2,'a') == 'a' and g(1,2,'a') == 1 and h(1,2,'a') == 1)
end)

tests:it("PUSHNIL handling", function()
    local a; if nil then a=1; else a=2; end;
    assert(a==2)
end)

tests:it("debug.getinfo name field", function()
    local function F (a)
      assert(debug.getinfo(1, "n").name == 'F')
      return a,2,3
    end

    local a,b = F(1)~=nil; assert(a == true and b == nil);
    a,b = F(nil)==nil; assert(a == true and b == nil)
end)

tests:it("syntax errors", function()
    checkload("for x do", "expected")
    checkload("x:call", "expected")
end)

tests:finish()

