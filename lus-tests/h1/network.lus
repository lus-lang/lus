--[[
  Network Library Tests for Lus
  Tests: TCP, UDP, and HTTP/HTTPS functionality
  
  Note: Uses 'catch' expression for protected execution.
]]

global pledge, print, network, type, assert, require, tostring, coroutine, string, error

pledge("load", "fs:read=./lus-tests/*", "network", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("network")

-- ============================================
-- Library Structure Tests
-- ============================================

tests:it("network global exists", function()
  assert(type(network) == "table", "network should be a table")
end)

tests:it("network.tcp subtable exists", function()
  assert(type(network.tcp) == "table", "network.tcp should be a table")
  assert(type(network.tcp.connect) == "function", "network.tcp.connect should be a function")
  assert(type(network.tcp.bind) == "function", "network.tcp.bind should be a function")
end)

tests:it("network.udp subtable exists", function()
  assert(type(network.udp) == "table", "network.udp should be a table")
  assert(type(network.udp.open) == "function", "network.udp.open should be a function")
end)

tests:it("network.fetch function exists", function()
  assert(type(network.fetch) == "function", "network.fetch should be a function")
end)

-- ============================================
-- TCP Basic Tests
-- ============================================

tests:it("TCP server bind and close", function()
  local server = network.tcp.bind("127.0.0.1", 19999)
  assert(server ~= nil, "server should be created")
  assert(tostring(server):find("server"), "tostring should indicate server")
  server:close()
  assert(tostring(server):find("closed"), "tostring should indicate closed")
end)

tests:it("TCP connection refused error", function()
  local ok, err = catch network.tcp.connect("127.0.0.1", 19997)
  assert(not ok, "should fail to connect to closed port")
  assert(type(err) == "string", "error should be string")
end)

tests:it("TCP server has expected methods", function()
  local server = network.tcp.bind("127.0.0.1", 19995)
  assert(type(server.accept) == "function", "should have accept")
  assert(type(server.close) == "function", "should have close")
  assert(type(server.settimeout) == "function", "should have settimeout")
  server:close()
end)

-- ============================================
-- UDP Tests
-- ============================================

tests:it("UDP socket create and close", function()
  local sock = network.udp.open()
  assert(sock ~= nil, "UDP socket should be created")
  assert(tostring(sock):find("udpsocket"), "tostring should indicate udpsocket")
  sock:close()
  assert(tostring(sock):find("closed"), "tostring should indicate closed")
end)

tests:it("UDP socket has expected methods", function()
  local sock = network.udp.open()
  assert(type(sock.sendto) == "function", "should have sendto")
  assert(type(sock.receive) == "function", "should have receive")
  assert(type(sock.setsockname) == "function", "should have setsockname")
  assert(type(sock.close) == "function", "should have close")
  sock:close()
end)

tests:it("UDP socket bind to port", function()
  local sock = network.udp.open(19994, "127.0.0.1")
  assert(sock ~= nil, "bound UDP socket should be created")
  sock:close()
end)

tests:it("using closed UDP socket raises error", function()
  local sock = network.udp.open()
  sock:close()
  local ok, err = catch sock:sendto("test", "127.0.0.1", 1234)
  assert(not ok, "should fail on closed socket")
  assert(err:find("closed"), "error should mention closed")
end)

-- ============================================
-- HTTP/HTTPS Tests
-- ============================================

-- TODO: More reliable domains. Please.

--[[
tests:soft("HTTPS GET request", function()
  -- This test requires network access
  local ok, result = catch network.fetch("https://httpbin.org/get")
  
  if not ok then
    print("Skipping HTTPS test - network unavailable: " .. tostring(result))
    return
  end
  
  local status, body, headers = network.fetch("https://httpbin.org/get")
  
  assert(status == 200, "status should be 200, got: " .. tostring(status))
  assert(#body > 0, "body should not be empty")
  assert(type(headers) == "table", "headers should be a table")
  assert(headers["content-type"] ~= nil, "should have content-type header")
end)

tests:soft("HTTPS POST request", function()
  local ok = catch network.fetch("https://httpbin.org/post", "POST", 
    {["Content-Type"] = "application/json"}, 
    '{"test": true}')
  
  if not ok then
    print("Skipping POST test - network unavailable")
    return
  end
  
  local status, body = network.fetch(
    "https://httpbin.org/post",
    "POST",
    {["Content-Type"] = "application/json"},
    '{"test": true}'
  )
  
  assert(status == 200, "POST status should be 200")
  assert(body:find('"test"'), "body should contain posted data")
end)
--]]

tests:it("DNS resolution failure", function()
  local ok, err = catch network.fetch("https://invalid.hostname.that.does.not.exist.example/")
  assert(not ok, "should fail for invalid hostname")
  assert(type(err) == "string", "error should be string")
end)

tests:finish()

