--[[
  Network Library Tests for Lus
  Tests: TCP, UDP, and HTTP/HTTPS functionality
  
  Note: Uses 'catch' expression for protected execution.
]]

global pledge, print, network, type, assert, require, tostring, coroutine, string, error

pledge("load", "fs:read=./lus-tests/*", "network", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("network")

-- ============================================
-- Library Structure Tests
-- ============================================

tests:it("network global exists", function()
  assert(type(network) == "table", "network should be a table")
end)

tests:it("network.tcp subtable exists", function()
  assert(type(network.tcp) == "table", "network.tcp should be a table")
  assert(type(network.tcp.connect) == "function", "network.tcp.connect should be a function")
  assert(type(network.tcp.bind) == "function", "network.tcp.bind should be a function")
end)

tests:it("network.udp subtable exists", function()
  assert(type(network.udp) == "table", "network.udp should be a table")
  assert(type(network.udp.open) == "function", "network.udp.open should be a function")
end)

tests:it("network.fetch function exists", function()
  assert(type(network.fetch) == "function", "network.fetch should be a function")
end)

-- ============================================
-- TCP Basic Tests
-- ============================================

tests:it("TCP server bind and close", function()
  local server = network.tcp.bind("127.0.0.1", 19999)
  assert(server ~= nil, "server should be created")
  assert(tostring(server):find("server"), "tostring should indicate server")
  server:close()
  assert(tostring(server):find("closed"), "tostring should indicate closed")
end)

tests:it("TCP connection refused error", function()
  local ok, err = catch network.tcp.connect("127.0.0.1", 19997)
  assert(not ok, "should fail to connect to closed port")
  assert(type(err) == "string", "error should be string")
end)

tests:it("TCP server has expected methods", function()
  local server = network.tcp.bind("127.0.0.1", 19995)
  assert(type(server.accept) == "function", "should have accept")
  assert(type(server.close) == "function", "should have close")
  assert(type(server.settimeout) == "function", "should have settimeout")
  server:close()
end)

-- ============================================
-- UDP Tests
-- ============================================

tests:it("UDP socket create and close", function()
  local sock = network.udp.open()
  assert(sock ~= nil, "UDP socket should be created")
  assert(tostring(sock):find("udpsocket"), "tostring should indicate udpsocket")
  sock:close()
  assert(tostring(sock):find("closed"), "tostring should indicate closed")
end)

tests:it("UDP socket has expected methods", function()
  local sock = network.udp.open()
  assert(type(sock.sendto) == "function", "should have sendto")
  assert(type(sock.receive) == "function", "should have receive")
  assert(type(sock.setsockname) == "function", "should have setsockname")
  assert(type(sock.close) == "function", "should have close")
  sock:close()
end)

tests:it("UDP socket bind to port", function()
  local sock = network.udp.open(19994, "127.0.0.1")
  assert(sock ~= nil, "bound UDP socket should be created")
  sock:close()
end)

tests:it("using closed UDP socket raises error", function()
  local sock = network.udp.open()
  sock:close()
  local ok, err = catch sock:sendto("test", "127.0.0.1", 1234)
  assert(not ok, "should fail on closed socket")
  assert(err:find("closed"), "error should mention closed")
end)

-- ============================================
-- HTTP/HTTPS Tests
-- ============================================

-- Using httpstat.us as a reliable HTTP testing service
-- These are soft tests because they depend on external network access

tests:soft("HTTPS GET request returns 200", function()
  -- httpstat.us/200 always returns status 200
  local status, body, headers = network.fetch("https://httpstat.us/200")
  
  assert(status == 200, "status should be 200, got: " .. tostring(status))
  assert(type(headers) == "table", "headers should be a table")
end)

tests:soft("HTTPS GET with different status codes", function()
  -- Test 201 Created
  local status201 = network.fetch("https://httpstat.us/201")
  assert(status201 == 201, "should get 201, got: " .. tostring(status201))
  
  -- Test 204 No Content
  local status204 = network.fetch("https://httpstat.us/204")
  assert(status204 == 204, "should get 204, got: " .. tostring(status204))
end)

tests:soft("HTTPS handles redirect", function()
  -- httpstat.us/301 redirects - fetch should follow redirects
  local status, body = network.fetch("https://httpstat.us/301")
  -- After redirect, should get 200 (or the redirect status if not following)
  assert(status == 200 or status == 301, "should handle redirect, got: " .. tostring(status))
end)

tests:soft("HTTPS client error status", function()
  -- Test 404 Not Found
  local status404 = network.fetch("https://httpstat.us/404")
  assert(status404 == 404, "should get 404, got: " .. tostring(status404))
  
  -- Test 400 Bad Request
  local status400 = network.fetch("https://httpstat.us/400")
  assert(status400 == 400, "should get 400, got: " .. tostring(status400))
end)

tests:soft("HTTPS server error status", function()
  -- Test 500 Internal Server Error
  local status500 = network.fetch("https://httpstat.us/500")
  assert(status500 == 500, "should get 500, got: " .. tostring(status500))
end)

tests:it("DNS resolution failure", function()
  local ok, err = catch network.fetch("https://invalid.hostname.that.does.not.exist.example/")
  assert(not ok, "should fail for invalid hostname")
  assert(type(err) == "string", "error should be string")
end)

tests:finish()

