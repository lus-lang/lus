global setmetatable, assert, type, require, fromjson, tojson, io, tostring, table, fs, string, pledge, ipairs, math

pledge("load", "fs:read=./lus-tests/*", "seal")

local framework = require("lus-tests.framework")
local tests = framework.new("json")

tests:it("fromjson parses null as nil", function()
    local result = fromjson("null")
    assert(result == nil, "null should parse to nil")
end)

tests:it("fromjson parses true", function()
    local result = fromjson("true")
    assert(result == true, "true should parse to true")
end)

tests:it("fromjson parses false", function()
    local result = fromjson("false")
    assert(result == false, "false should parse to false")
end)

tests:it("fromjson parses integer", function()
    local result = fromjson("42")
    assert(result == 42, "42 should parse to 42")
end)

tests:it("fromjson parses negative integer", function()
    local result = fromjson("-123")
    assert(result == -123, "-123 should parse to -123")
end)

tests:it("fromjson parses float", function()
    local result = fromjson("-3.14")
    assert(result == -3.14, "-3.14 should parse to -3.14")
end)

tests:it("fromjson parses exponential notation", function()
    local result = fromjson("1.5e10")
    assert(result == 1.5e10, "1.5e10 should parse correctly")
end)

tests:it("fromjson parses simple string", function()
    local result = fromjson('"hello"')
    assert(result == "hello", '"hello" should parse to hello')
end)

tests:it("fromjson parses empty string", function()
    local result = fromjson('""')
    assert(result == "", '"" should parse to empty string')
end)

tests:it("fromjson parses escape sequences", function()
    assert(fromjson('"a\\nb"') == "a\nb", "\\n should become newline")
    assert(fromjson('"a\\tb"') == "a\tb", "\\t should become tab")
    assert(fromjson('"a\\\\b"') == "a\\b", "\\\\ should become backslash")
    assert(fromjson('"a\\"b"') == 'a"b', '\\" should become quote')
end)

tests:it("fromjson parses unicode escape", function()
    local result = fromjson('"\\u0041"')
    assert(result == "A", "\\u0041 should be A")
end)

tests:it("fromjson parses surrogate pairs", function()
    -- U+1F600 (grinning face) = \uD83D\uDE00
    local result = fromjson('"\\uD83D\\uDE00"')
    assert(result == "\xF0\x9F\x98\x80", "surrogate pair should decode correctly")
end)

tests:it("fromjson parses empty array", function()
    local result = fromjson("[]")
    assert(type(result) == "table", "[] should be table")
    assert(#result == 0, "[] should be empty")
end)

tests:it("fromjson parses array with values", function()
    local result = fromjson("[1, 2, 3]")
    assert(type(result) == "table", "[1,2,3] should be table")
    assert(result[1] == 1, "first element should be 1")
    assert(result[2] == 2, "second element should be 2")
    assert(result[3] == 3, "third element should be 3")
end)

tests:it("fromjson parses nested array", function()
    local result = fromjson("[[1, 2], [3, 4]]")
    assert(result[1][1] == 1, "nested access failed")
    assert(result[2][2] == 4, "nested access failed")
end)

tests:it("fromjson parses empty object", function()
    local result = fromjson("{}")
    assert(type(result) == "table", "{} should be table")
end)

tests:it("fromjson parses object with values", function()
    local result = fromjson('{"name":"test","value":123}')
    assert(result.name == "test", "name should be test")
    assert(result.value == 123, "value should be 123")
end)

tests:it("fromjson parses nested object", function()
    local result = fromjson('{"a":{"b":{"c":42}}}')
    assert(result.a.b.c == 42, "nested access should work")
end)

tests:it("fromjson parses mixed nested structure", function()
    local result = fromjson('{"arr":[1,2],"obj":{"x":true}}')
    assert(result.arr[1] == 1, "array in object failed")
    assert(result.obj.x == true, "object in object failed")
end)

tests:it("fromjson handles whitespace", function()
    local result = fromjson('  { "a" : 1 }  ')
    assert(result.a == 1, "whitespace should be ignored")
end)

tests:it("fromjson rejects invalid JSON", function()
    local ok, err = catch fromjson("not json")
    assert(ok == false, "invalid JSON should error")
end)

tests:it("fromjson rejects trailing comma in array", function()
    local ok, err = catch fromjson("[1, 2,]")
    assert(ok == false, "trailing comma should error")
end)

tests:it("fromjson rejects unquoted keys", function()
    local ok, err = catch fromjson("{key: 1}")
    assert(ok == false, "unquoted keys should error")
end)

tests:it("fromjson rejects single quotes", function()
    local ok, err = catch fromjson("'hello'")
    assert(ok == false, "single quotes should error")
end)

tests:it("fromjson rejects control characters in string", function()
    local ok, err = catch fromjson('"hello\tworld"')
    assert(ok == false, "unescaped tab should error")
end)

tests:it("tojson serializes nil as null", function()
    local result = tojson(nil)
    assert(result == "null", "nil should serialize to null")
end)

tests:it("tojson serializes true", function()
    local result = tojson(true)
    assert(result == "true", "true should serialize to true")
end)

tests:it("tojson serializes false", function()
    local result = tojson(false)
    assert(result == "false", "false should serialize to false")
end)

tests:it("tojson serializes integer", function()
    local result = tojson(42)
    assert(result == "42", "42 should serialize to 42")
end)

tests:it("tojson serializes negative integer", function()
    local result = tojson(-123)
    assert(result == "-123", "-123 should serialize to -123")
end)

tests:it("tojson serializes simple string", function()
    local result = tojson("hello")
    assert(result == '"hello"', "hello should serialize to \"hello\"")
end)

tests:it("tojson escapes special characters", function()
    assert(tojson("a\nb") == '"a\\nb"', "newline should be escaped")
    assert(tojson("a\tb") == '"a\\tb"', "tab should be escaped")
    assert(tojson("a\\b") == '"a\\\\b"', "backslash should be escaped")
    assert(tojson('a"b') == '"a\\"b"', "quote should be escaped")
end)

tests:it("tojson serializes empty table as empty array", function()
    local result = tojson({})
    assert(result == "[]", "empty table should be []")
end)

tests:it("tojson serializes array", function()
    local result = tojson({1, 2, 3})
    assert(result == "[1,2,3]", "array should serialize correctly")
end)

tests:it("tojson serializes object", function()
    local result = tojson({a = 1})
    assert(result == '{"a":1}', "object should serialize correctly")
end)

tests:it("tojson serializes nested structure", function()
    local data = {arr = {1, 2}, obj = {x = true}}
    local result = tojson(data)
    -- Order of keys is not guaranteed, so check for presence
    assert(result:find('"arr"'), "should contain arr key")
    assert(result:find('%[1,2%]'), "should contain array value")
end)

tests:it("tojson handles inf as null", function()
    local result = tojson(1/0)
    assert(result == "null", "inf should serialize as null")
end)

tests:it("tojson handles -inf as null", function()
    local result = tojson(-1/0)
    assert(result == "null", "-inf should serialize as null")
end)

tests:it("tojson handles nan as null", function()
    local result = tojson(0/0)
    assert(result == "null", "nan should serialize as null")
end)

tests:it("tojson calls __json metamethod", function()
    local mt = {
        __json = function(self)
            return {id = self.secret}
        end
    }
    local obj = setmetatable({secret = 42, private = "hidden"}, mt)
    local result = tojson(obj)
    assert(result == '{"id":42}', "__json should transform value")
end)

tests:it("tojson filter can omit properties", function()
    local data = {a = 1, b = 2, c = 3}
    local result = tojson(data, function(k, v)
        if k == "b" then return nil end
        return v
    end)
    assert(not result:find('"b"'), "b should be omitted")
    assert(result:find('"a"'), "a should be present")
    assert(result:find('"c"'), "c should be present")
end)

tests:it("tojson filter can transform values", function()
    local data = {x = "original"}
    local result = tojson(data, function(k, v)
        if k == "x" then return "transformed" end
        return v
    end)
    assert(result == '{"x":"transformed"}', "filter should transform value")
end)

tests:it("tojson skips functions", function()
    local data = {a = 1, fn = function() end}
    local result = tojson(data)
    assert(not result:find("fn"), "functions should be skipped")
end)

tests:it("tojson detects circular references", function()
    local a = {}
    a.self = a
    local ok, err = catch tojson(a)
    assert(ok == false, "circular reference should error")
end)

-- ============================================================
-- roundtrip tests
-- ============================================================

tests:it("roundtrip preserves string", function()
    local original = "hello world"
    local result = fromjson(tojson(original))
    assert(result == original, "string roundtrip failed")
end)

tests:it("roundtrip preserves number", function()
    local original = 123.456
    local result = fromjson(tojson(original))
    assert(result == original, "number roundtrip failed")
end)

tests:it("roundtrip preserves boolean", function()
    assert(fromjson(tojson(true)) == true, "true roundtrip failed")
    assert(fromjson(tojson(false)) == false, "false roundtrip failed")
end)

tests:it("roundtrip preserves nil", function()
    local result = fromjson(tojson(nil))
    assert(result == nil, "nil roundtrip failed")
end)

tests:it("roundtrip preserves simple object", function()
    local original = {name = "test", value = 123, active = true}
    local json = tojson(original)
    local parsed = fromjson(json)
    assert(parsed.name == "test", "name mismatch")
    assert(parsed.value == 123, "value mismatch")
    assert(parsed.active == true, "active mismatch")
end)

tests:it("roundtrip preserves nested structure", function()
    local original = {
        level1 = {
            level2 = {
                data = "deep"
            }
        }
    }
    local json = tojson(original)
    local parsed = fromjson(json)
    assert(parsed.level1.level2.data == "deep", "nested roundtrip failed")
end)

tests:it("roundtrip preserves array", function()
    local original = {1, 2, 3, 4, 5}
    local json = tojson(original)
    local parsed = fromjson(json)
    assert(#parsed == 5, "array length mismatch")
    assert(parsed[3] == 3, "array value mismatch")
end)

-- RFC 8259 Test Suite (if h1/json folder exists)
local function readfile(path)
    local f = io.open(path, "rb")
    if not f then return nil end
    local content = f:read("*a")
    f:close()
    return content
end

local function get_json_test_files()
    local json_dir = "lus-tests/h1/json"
    
    -- Check if directory exists using fs.type
    local ok = catch fs.type(json_dir)
    if not ok then return nil end
    
    -- Use fs.list to get JSON files
    local list_ok, all_files = catch fs.list(json_dir, "*.json")
    if not list_ok then return nil end
    
    local files = {y = {}, n = {}, i = {}}
    
    for idx = 1, #all_files do
        local basename = all_files[idx]
        local prefix = string.sub(basename, 1, 1)
        local path = fs.path.join(json_dir, basename)
        
        if prefix == "y" then
            files.y[#files.y + 1] = {path = path, name = basename}
        elseif prefix == "n" then
            files.n[#files.n + 1] = {path = path, name = basename}
        elseif prefix == "i" then
            files.i[#files.i + 1] = {path = path, name = basename}
        end
    end
    
    if #files.y == 0 and #files.n == 0 and #files.i == 0 then
        return nil
    end
    return files
end

local json_files = get_json_test_files()

if json_files then
    -- y_* files (must parse successfully)
    for i = 1, #json_files.y do
        local file = json_files.y[i]
        tests:it("RFC8259 y_: " .. file.name, function()
            local content = readfile(file.path)
            assert(content, "Failed to read file: " .. file.path)
            fromjson(content)
        end)
    end
    
    -- n_* files (must fail to parse)
    for i = 1, #json_files.n do
        local file = json_files.n[i]
        tests:it("RFC8259 n_: " .. file.name, function()
            local content = readfile(file.path)
            assert(content, "Failed to read file: " .. file.path)
            local ok, err = catch fromjson(content)
            assert(not ok, "Expected parse error but got success")
        end)
    end
    
    -- i_* files (implementation-defined, soft-fail)
    for i = 1, #json_files.i do
        local file = json_files.i[i]
        tests:it("RFC8259 i_: " .. file.name, function()
            local content = readfile(file.path)
            assert(content, "Failed to read file: " .. file.path)
            catch fromjson(content)
            -- Implementation-defined: either parse or error is acceptable
        end)
    end
end

-- ============================================
-- Stress Tests
-- ============================================

tests:it("deeply nested objects", function()
    -- Create deeply nested structure
    local depth = 50
    local json_str = string.rep('{"a":', depth) .. '1' .. string.rep('}', depth)
    
    local result = fromjson(json_str)
    
    -- Verify nesting
    local current = result
    for i = 1, depth do
        assert(type(current) == "table", "level " .. i .. " should be table")
        current = current.a
    end
    assert(current == 1, "innermost value should be 1")
end)

tests:it("deeply nested arrays", function()
    local depth = 50
    local json_str = string.rep('[', depth) .. '42' .. string.rep(']', depth)
    
    local result = fromjson(json_str)
    
    local current = result
    for i = 1, depth do
        assert(type(current) == "table", "level " .. i .. " should be table")
        current = current[1]
    end
    assert(current == 42, "innermost value should be 42")
end)

tests:it("large array", function()
    local parts = {}
    for i = 1, 1000 do
        parts[i] = tostring(i)
    end
    local json_str = '[' .. table.concat(parts, ',') .. ']'
    
    local result = fromjson(json_str)
    
    assert(#result == 1000, "should have 1000 elements")
    assert(result[1] == 1, "first element")
    assert(result[500] == 500, "middle element")
    assert(result[1000] == 1000, "last element")
end)

tests:it("large object", function()
    local parts = {}
    for i = 1, 500 do
        parts[i] = string.format('"key%d":%d', i, i)
    end
    local json_str = '{' .. table.concat(parts, ',') .. '}'
    
    local result = fromjson(json_str)
    
    assert(result.key1 == 1)
    assert(result.key250 == 250)
    assert(result.key500 == 500)
end)

tests:it("long string value", function()
    local long_str = string.rep("x", 10000)
    local json_str = tojson(long_str)
    local result = fromjson(json_str)
    
    assert(result == long_str, "long string should roundtrip")
    assert(#result == 10000, "length should be preserved")
end)

tests:it("string with many escapes", function()
    local str_with_escapes = ""
    for i = 1, 100 do
        str_with_escapes = str_with_escapes .. "\n\t\r\\\""
    end
    
    local json_str = tojson(str_with_escapes)
    local result = fromjson(json_str)
    
    assert(result == str_with_escapes, "escaped string should roundtrip")
end)

tests:it("unicode strings", function()
    local tests_data = {
        "Hello, ‰∏ñÁïå!",          -- Chinese
        "–ü—Ä–∏–≤–µ—Ç –º–∏—Ä",            -- Russian
        "ŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ",         -- Arabic
        "üéâüéäüéÅ",                 -- Emoji
        "‚àë‚àè‚à´‚àÇ",                  -- Math symbols
        "\u{1F600}\u{1F601}",    -- More emoji via escape
    }
    
    for _, str in ipairs(tests_data) do
        local json_str = tojson(str)
        local result = fromjson(json_str)
        assert(result == str, "unicode string should roundtrip: " .. str)
    end
end)

tests:it("mixed nested structure", function()
    local data = {
        name = "test",
        values = {1, 2, 3, {nested = true}},
        metadata = {
            created = "2024-01-01",
            tags = {"a", "b", "c"},
            config = {
                enabled = true,
                count = 42,
                ratio = 3.14
            }
        }
    }
    
    local json_str = tojson(data)
    local result = fromjson(json_str)
    
    assert(result.name == "test")
    assert(result.values[1] == 1)
    assert(result.values[4].nested == true)
    assert(result.metadata.config.enabled == true)
    assert(result.metadata.config.count == 42)
end)

tests:it("tojson with many repeated keys", function()
    local data = {}
    for i = 1, 100 do
        data["repeated_key_name_" .. i] = i
    end
    
    local json_str = tojson(data)
    local result = fromjson(json_str)
    
    for i = 1, 100 do
        assert(result["repeated_key_name_" .. i] == i)
    end
end)

tests:it("numeric precision", function()
    local numbers = {
        0,
        1,
        -1,
        0.5,
        -0.5,
        1e10,
        1e-10,
        123456789,
        -123456789,
        3.141592653589793,
    }
    
    for _, n in ipairs(numbers) do
        local json_str = tojson(n)
        local result = fromjson(json_str)
        -- Allow small floating point differences
        local diff = math.abs(result - n)
        local tolerance = math.abs(n) * 1e-10
        if tolerance < 1e-15 then tolerance = 1e-15 end
        assert(diff <= tolerance, "number " .. n .. " should roundtrip, got " .. result)
    end
end)

tests:it("whitespace handling variations", function()
    -- Various whitespace combinations that are valid JSON
    local test_cases = {
        '  {"a":1}  ',
        '\n\t{\n\t"a"\n:\n1\n}\n',
        '{"a" : 1}',
        '{ "a" : 1 }',
        '[  1  ,  2  ,  3  ]',
    }
    
    for _, json_str in ipairs(test_cases) do
        local ok, result = catch fromjson(json_str)
        assert(ok, "should parse: " .. json_str)
    end
end)

tests:it("boolean and null edge cases", function()
    -- Array of booleans and nulls
    local json_str = '[true, false, null, true, null, false]'
    local result = fromjson(json_str)
    
    assert(result[1] == true)
    assert(result[2] == false)
    assert(result[3] == nil)
    assert(result[4] == true)
    assert(result[5] == nil)
    assert(result[6] == false)
end)

tests:it("empty structures", function()
    assert(type(fromjson('{}')) == "table")
    assert(type(fromjson('[]')) == "table")
    assert(#fromjson('[]') == 0)
    
    -- Nested empty
    local result = fromjson('{"a":{}, "b":[]}')
    assert(type(result.a) == "table")
    assert(type(result.b) == "table")
end)

tests:it("duplicate keys behavior", function()
    -- JSON spec says behavior is implementation-defined
    -- Most implementations use the last value
    local json_str = '{"a":1, "a":2}'
    local result = fromjson(json_str)
    -- Just verify it parses without error
    assert(type(result) == "table")
end)

tests:finish()
